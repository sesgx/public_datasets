{
  "name": "ferrari",
  "gs": [
    {
      "id": 1,
      "title": "Static Dataflow-aided Weak Mutation Analysis (SDAWM)",
      "abstract": "A new static analysis methodology (known as static dataflow-aided weak mutation (SDAWM) intended for use as a preprocessor to a variable mutation system is described. The procedure is based around a marriage of existing static dataflow analysis concepts and weak mutation ideas. The (dataflow) path expression of a variable is analysed to assess what the impact of strong mutation would be if it was performed. A methodology is presented that pre-empts strong or weak mutation by removing a significant number of variable mutants statically and without actually creating them, thus saving processor time later. ",
      "keywords": "software testing, static dataflow analysis, mutation analysis, dataflow",
      "references": []
    },
    {
      "id": 2,
      "title": "A Bayes Sequential Statistical Procedure for Approving Software Products",
      "abstract": "Mutation analysis is a well-studied method of measuring test-case adequacy. Mutation analysis involves the mutation of a program by introduction of a small syntactic change in the software. Existing test data sets are then executed against all these mutant programs. If the test data set is adequate for testing the original program, it will distinguish all of the incorrect mutant programs from the original program. As an ad-hoc procedure, a stopping criterion is conventionally based on a given \\Y% of the mutants to be distinguished\" with a certain copendence level of X%\" over a multiplicity of random test cases. Alternatively, we propose a Bayes sequential procedure for testing H0 : p = p1 (acceptable fraction of live mutants to demonstrate good quality) vs. HA : p = p2 (unacceptable fraction of live mutants to demonstrate bad quality). This derives a sequential probability ratio testing (SPRT) that is the most economical sampling scheme with given prior probabilities, decision and sampling cost functions. The implementation of our proposed method on a sample program shows the cost effectiveness of the new technique as compared to the current, deterministic approach, which was not structured by statistical hypothesis testing.",
      "keywords": "",
      "references": []
    },
    {
      "id": 3,
      "title": "Compiler-integrated Program Mutation",
      "abstract": "Software testing is of critical importance to the software development life cycle. Consequently, tools that aid the developer/tester are of great interest. Traditionally, available compilers have supported only two simple testing techniques, namely, statement and branch coverage. However, during compilation, sufficient syntactic and semantic information is available to provide support for more sophisticated testing techniques. This paper presents a novel method to efficiently support program mutation via information and code generated at compile-time.",
      "keywords": "",
      "references": []
    },
    {
      "id": 4,
      "title": "High Performance Software Testing on SIMD Machines",
      "abstract": "This paper describes a new method, called mutant unification, for high-performance software testing. The method is aimed at supporting program mutation on parallel machines based on the Single Instruction Multiple Data stream (SIMD) paradigm. Several parameters that affect the performance of unification have been identified and their effect on the time to completion of a mutation test cycle and speedup has been studied. Program mutation analysis provides an effective means for determining the reliability of large software systems. It also provides a systematic method for measuring the adequacy of test data. However, it is likely that testing large software systems using mutation is computation bound and prohibitive on traditional sequential machines. Current implementations of mutation tools are unacceptably slow and are only suitable for testing relatively small programs. The unification method reported in this paper provides a practical alternative to the current approaches. It also opens up a new application domain for SIMD machines.",
      "keywords": "Mutation testing, SIMD Machines, unification, Urm Models",
      "references": []
    },
    {
      "id": 5,
      "title": "Mutation Testing of Software Using a MIMD Computer",
      "abstract": "Mutation testing is a fault-based method for testing software that is computationally expensive.Mothra is an interpreter-based mutation testing system that is centered around an interpreter. This paper presents a parallel implementation of Mothra's inter- preter on a MIMD machine. The parallel interpreter, IyperMothra, is implemented on a sizteen pro Intel iPSC/2 hypercube. Our goal was to demonstrate that the expense of software testing schemes such as mutation can be reduced by using parallel pro- cessing, and we demonstrate this by measuring the performance gains of the parallel interpreter over the Mothra interpreter. Results are presented using ten test programs, three different static work distribution schemes, and various numbers of processors. On our test programs, we found that our parallel interpreter achicved almost lincar speedup over Mothra's sequen- tial interpreter. With larger, faster high-performance computers available, mutation testing can be done at significantly less expense.",
      "keywords": "",
      "references": []
    },
    {
      "id": 6,
      "title": "High-Performance Mutation Testing",
      "abstract": "Testing a large software program is a time consuming operation. In addition to the time spent by the tester in identifying, locating, and correcting bugs, a significant amount of time is spent in the execution of the program under test and its instrumented or fault-induced variants, also known as mutants. When using mutation testing to achieve high reliability, there can be many such mutants. In this article, we show how a multiple instruction multiple data (MIMD) architecture can be exploited to obtain significant reductions in the total execution time of the mutants. We describe the architecture of the PM othra system, which is designed to provide the tester with a transparent interface to a parallel machine. Experimental results obtained on the Ncube/7 hypercube are presented. The near-linear speedups show the perfect match that exists between the software testing application and a local memory MIMD architecture typified by the Ncube/7 machine. The compilation bottleneck, which could have an adverse effect on the speedup, is illustrated by experimental results. ",
      "keywords": "",
      "references": [
        3
      ]
    },
    {
      "id": 7,
      "title": "Experimental Results from an Automatic Test Case Generator",
      "abstract": " Constraint-based testing is a novel way of generating test data to detect specific types of common programming faults. The conditions under which faults will be detected are encoded as mathematical systems of constraints in terms of program symbols. A set of tools, collectively called Godzilla, has been implemented that automatically generates constraint systems and solves them to create test cases for use by the Mothra testing system. Experimental results from using Godzilla show that the technique can produce test data that is very close in terms of mutation adequacy to test data that is produced manually, and at substantially reduced cost. Additionally, these experiments have suggested a new procedure for unit testing, where test cases are viewed as throw-away items rather than scarce resources.",
      "keywords": "adequacy; constraints; mutation analysis",
      "references": []
    },
    {
      "id": 8,
      "title": "An Experimental Evaluation of Selective Mutation",
      "abstract": "Mutation testing is a technique for unit-testing software that, although powerful, is computationally ezpensive. The principal ezpense of mutation is that many variants of the test program, called mutants, must be repeatedly ezecuted. Selective mutation is a way to approzimate mutation testing that saves ezecution bv reducing the number of mutants that must be ezecuted. This paper reports ezperimental results that compare selective mutation testing to standard,or non-selective, mutation testing. The results support the hypothesis that selective mutation is almost as strong as non-selective mutation; in ezperimental trials selective mutation provides almost the same covemge as non-selective mutation, with significant reductions in cost. ",
      "keywords": "",
      "references": []
    },
    {
      "id": 9,
      "title": "Mutation Analysis Using Mutant Schemata",
      "abstract": " Mutation analysis is a powerful technique for assessing and improving the quality of test data used to unit test software. Unfortunately, current automated mutation analysis systems suffer from severe performance problems. This paper presents a new method for performing mutation analysis that uses program schemata to encode all mutants for a program into one metaprogram, which is subsequently compiled and run at speeds substantially higher than achieved by previous interpretive systems. Preliminary performance improvements of over 300% are reported. This method has the additional advantages of being easier to implement than interpretive systems, being simpler to port across a wide range of hardware and software platforms, and using the same compiler and run-time support system that is used during development and/or deployment.",
      "keywords": "Fault-based testing, mutation analysis, program schemata, software testing.",
      "references": [
        3,
        4,
        5,
        6,
        8,
        12
      ]
    },
    {
      "id": 10,
      "title": "Improved Serial Algorithms for Mutation Analysis",
      "abstract": " Existing serial algorithms to do mutation analysis are inefficient, and descriptions of parallel mutation systems presuppose that these serial algorithms are the best one can do serially. We present a universal mutation analysis data structure and new serial algorithms for both strong and weak mutation analysis that on average should perform much faster than existing ones, and can never do worse. We describe these algorithms as well as the results of our analysis of their run time complexities. We believe that this is the first paper in which analytical methods have been applied to obtain the run time complexities of mutation analysis algorithms.",
      "keywords": "",
      "references": [
        3,
        4
      ]
    },
    {
      "id": 11,
      "title": "Efficient Mutation Analysis: A New Approach",
      "abstract": " In previously reported research we designed and analyzed algorithms that improved upon the run time complexity of all known weak and strong mutation analysis methods at the expense of increased space complexity. Here we describe a new serial strong mutation algorithm whose running time is on the average much faster than the previous ones and that uses significantly less space than them also. Its space requirement is approximately the same as that of Mothra, a well-known and readily available implemented system. Moreover, while this algorithm can serve as basis for a new mutation system, it is designed to be consistent with the Mothra architecture, in the sense that, by replacing certain modules of that system with new ones, a much faster system will result. Such a Mothra-based implementation of the new work is in progress. Like the previous algorithms, this one, which we call Lazy Mutant Analysis or LMA, tries to determine whether a mutant is strongly killed by a given test only if it is already known that it is weakly killed by that test. Unlike those algorithms, LMA avoids executing many mutants by dynamically discovering classes of mutants that have the \"same\" behavior, and executing representatives of those classes. The overhead it incurs is small in proportion to the time saved, and the algorithm has a very natural parallel implementation. In comparison to the fastest known algorithms for strong mutation analysis, in the best case, LMA can improve the speed by a factor proportional to the average number of mutants per program statement. In the worst case, there is no improvement in the running time, but such a case is hard to construct. This work enables us to apply mutation analysis to significantly larger programs than is currently possible. ",
      "keywords": "",
      "references": [
        4,
        9,
        10
      ]
    },
    {
      "id": 12,
      "title": "Using Compiler Optimization Techniques to Detect Equivalent Mutants",
      "abstract": " Mutation analysis is a software testing technique that requires the tester to generate test data that will find specific, well\u2010defined errors. Mutation testing executes many slightly differing versions, called mutants, of the same program to evaluate the quality of the data used to test the program. Although these mutants are generated and executed efficiently by automated methods, many of the mutants are functionally equivalent to the original program and are not useful for testing. Recognizing and eliminating equivalent mutants is currently done by hand, a time\u2010consuming and arduous task. This problem is currently a major obstacle to the practical application of mutation testing. This paper presents extensions to previous work in detecting equivalent mutants; specifically, algorithms for determining several classes of equivalent mutants are presented, an implementation of these algorithms is discussed, and results from using this implementation are presented. These algorithms are based on data flow analysis and six compiler optimization techniques. Each of these techniques is described together with how they are used to detect equivalent mutants. The design of the tool and some experimental results using it are also presented.",
      "keywords": "Compiler optimizations; Experimental software engineering; Mutation testing; Software testing",
      "references": [
        7,
        84
      ]
    },
    {
      "id": 13,
      "title": "An Empirical Evaluation of Weak Mutation",
      "abstract": " Mutation testing is a fault-based technique for unit-level software testing. Weak mutation was proposed as a way to reduce the expense of mutation testing. Unfortunately, weak mutation is also expected to provide a weaker test of the software than mutation testing does. This paper presents results from an implementation of weak mutation, which we used to evaluate the effectiveness versus the efficiency of weak mutation. Additionally, we examined several options in an attempt to find the most appropriate way to implement weak mutation. Our results indicate that weak mutation can be applied in a manner that is almost as effective as mutation testing, and with significant computational savings. ",
      "keywords": "Fault-based testing; firm mutation; mutation; software testing; testing; weak mutation",
      "references": [
        3,
        5,
        6,
        8,
        17
      ]
    },
    {
      "id": 14,
      "title": "Constrained Mutation in C Programs",
      "abstract": "Software development is always under the pressure of time and budget constraints before release. A good testing strategy should not only be effective and economical but also incre- mental. Although mutation testing has been empirically found to be effective in detecting faults, it remains unused for reasons of economics. A major obstacle to the use of mutation testing s its high computational cost. In this paper we report results from experiments de- signed to investigate six different constrained mutation mechanisms. Our data indicate that these alternatives not only reduce the cost of mutation significantly in terms of the number of test cases required and the number of mutants Lo be examined, but also maintain very good fault detection effectiveness. Effects of incremental mutation testing examining different sets of mutants are also discussed. Furthermore, our experiments are unique in that consirained mutation was performed directly on C programs. This eliminates the possible bias experi- enced by eaclier mutation studies because of the programming language translation between the Fortran, Pascal, and C. ",
      "keywords": "Mutation. constrained mutation, fault detection effectiveness ",
      "references": [
        4,
        8,
        10,
        15
      ]
    },
    {
      "id": 15,
      "title": "Reducing the Cost of Mutation Testing: An Empirical Study",
      "abstract": " Of the various testing strategies, mutation testing has been empirically found to be effective in detecting faults. However, mutation often imposes unacceptable demands on computing and human resources because of the large number of mutants that need to be compiled and executed on one or more test cases. In addition, the tester needs to examine many mutants and analyze these for possible equivalence with the program under test. For these reasons, mutation is generally regarded as too expensive to use. Because one significant component of the cost of mutation is the execution of mutants against test cases, we believe that this cost can be reduced dramatically by reducing the number of mutants that need to be examined. We report results from a case study designed to investigate two alternatives for reducing the cost of mutation. The alternatives considered are randomly selected x% mutation and constrained abs/ror mutation. We provide experimental data indicating that both alternatives lead to test sets that distinguish a significant number of nonequivalent mutants and provide high all-uses coverage. ",
      "keywords": "",
      "references": []
    },
    {
      "id": 16,
      "title": "Mutation Versus All-uses: An Empirical Evaluation of Cost, Strength and Effectiveness",
      "abstract": "Although mutation has been empirically found to be effective in detecting faults, it often imposes unacceptable demands on computing and human resources because of the large number of mutants that need to be compiled and executed on one or more test cases. We designed a case study to explore two alterna.tives of mutation to reduce its cost without significantly deteriorating its strength and effectiveness. The alternatives are (1) constrained abs/ror mutation which examines only the abs and ror mutants and ignores the others, and (2) randomly selected 10% mutation which examines only 10% of the randomly selected mutants of each mutation operator in Mothra. Data collected during experimentation have shown tha.t both alternatives provide a significant cost reduction in terms of the number of test cases required to satisfy an adequacy criterion and the number of mutants to be examined. Such gain is accompanied by a small strength loss in the a.bility to distinguish non-equivalent mutants and cover feasible all-uses. In terms of decreasing order of fault detection effectiveness the ranking is mutation, constrained abs/ror mutation, all-uses, and randomly selected 10% mutation. These data suggest that examining only a small percentage of the mutants may be a useful heuristic for evaluating and constructing test sets in practice. ",
      "keywords": "Software Testing, Cost, Strength, Effectiveness, Mutation, All-uses",
      "references": [
        4,
        10,
        15
      ]
    },
    {
      "id": 17,
      "title": "An Experimental Determination of Sufficient Mutant Operators",
      "abstract": " Mutation testing is a technique for unit-testing software that, although powerful, is computationally expensive. The principal expense of mutation is that many variants of the test program, called mutants, must be repeatedly executed. This article quantifies the expense of mutation in terms of the number of mutants that are created, then proposes and evaluates a technique that reduces the number of mutants by an order of magnitude. Selective mutation reduces the cost of mutation testing by reducing the number of mutants. This article reports experimental results that compare selective mutation testing with standard, or nonselective, mutation testing, and results that quantify the savings achieved by selective mutation testing. The results support the hypothesis that selective mutation is almost as strong as nonselective mutation; in experimental trials selective mutation provides almost the same coverage as nonselective mutation, with a four-fold or more reduction in the number of mutants.",
      "keywords": "Testing and debugging - test data generators; Experimentation; Measurement; Reliability",
      "references": [
        6,
        7,
        8,
        13
      ]
    },
    {
      "id": 18,
      "title": "Automatically Detecting Equivalent Mutants and Infeasible Paths",
      "abstract": "Mutation testing is a technique for testing software units that has great potential for improving the quality of testing, and thereby increasing the ability to assure the high reliability of critical software. It will be shown that recent advances in mutation research have brought a practical mutation testing system closer to reality. One recent advance is a partial solution to the problem of automatically detecting equivalent mutant programs. Equivalent mutants are currently detected by hand, which makes it very expensive and time-consuming. The problem of detecting equivalent mutants is a specific instance of a more general problem, commonly called the feasible path problem, which says that for certain structural testing criteria some of the test requirements are infeasible in the sense that the semantics of the program imply that no test case satisfies the test requirements. Equivalent mutants, unreachable statements in path testing techniques, and infeasible DU-pairs in data flow testing are all instances of the feasible path problem. This paper presents a technique that uses mathematical constraints, originally developed for test data generation, to detect some equivalent mutants and infeasible paths automatically.",
      "keywords": "Constraints; Feasible path analysis; Mutation testing; Software testing",
      "references": [
        12,
        17,
        84
      ]
    },
    {
      "id": 19,
      "title": "TUMS: Testing Using Mutant Schemata",
      "abstract": " Mutation analysis is a way of quantifying the quality of a test set used in unit testing software. Unfortunately, mutation analysis performed using the conventional interpretive method is very slow. A new non-interpretive method, the MSG method, that has the promise of much higher performance was recently advanced. In this paper we describe TUMS, a prototype MSG-based implementation of a mutation analysis system. We also describe several experiments using this prototype that compare the performance of mutation analysis using the MSG method with mutation analysis using the conventional method. Our experiments strongly suggest that using the new MSG method is significantly faster than using the conventional method, with speed-ups as high as an order-of-magnitude observed.",
      "keywords": "",
      "references": [
        4,
        6,
        17
      ]
    },
    {
      "id": 20,
      "title": "Using Program Slicing to Assist in the Detection of Equivalent Mutants",
      "abstract": " While mutation testing has proved to be an effective way of finding software faults, currently it is only applied to relatively small programs. One of the main reasons for this is the human analysis required in detecting equivalent mutants. Here program slicing is used to simplify this problem. Program slicing is also used to reduce the number of equivalent mutants produced.",
      "keywords": "mutation testing; program slicing; equivalent mutants; stubborn mutants",
      "references": [
        12,
        17,
        18
      ]
    },
    {
      "id": 21,
      "title": "Efficiency of Mutation Operators and Selective Mutation Strategies: an Empirical Study",
      "abstract": " This paper investigates the mutation scores achieved by individual operators of the Mothra mutation system and their associated costs in order to determine the most efficient operators. The cost of mutation analysis includes both test set generation and equivalent mutant detection. The score and cost information is then used as a heuristic for choosing a subset of the operators for use in efficient selective mutation testing. Experiments were performed using a sample of 11 programs and a number of test sets for each program. The results show that the use of efficient operators can provide significant efficiency gains for selective mutation if the acceptable mutation score is not very close to one. When mutation scores very close to one are required, a randomly selected proportion of the mutants provides a more efficient strategy than a subset of efficient operators.",
      "keywords": "software testing; selective mutation testing; mutation operators; efficiency",
      "references": [
        8,
        10,
        13,
        15,
        17,
        18
      ]
    },
    {
      "id": 22,
      "title": "The Relationship Between Program Dependence and Mutation Analysis",
      "abstract": "This paper presents some connections between dependence analysis and mutation testing. Specifically, dependence analysis can be applied to two problems in mutation testing, captured by the questions: 1. How do we avoid the creation of equivalent mutants? 2. How do we generate test data that kills non-equivalent mutants? The theoretical connections described here suggest ways in which a dependence analysis tool might be used, in combination with existing tools for mutation testing, for test-data generation and equivalent-mutant detection. In this paper the variable orientated, fine grained dependence framework of Jackson and Rollins is used to achieve these two goals. This framework of dependence analysis appears to be better suited to mutation testing than the more traditional, Program Dependence Graph (PDG) approach, used in slicing and other forms of program analysis. The relationship between dependence analysis and mutation testing is used to defined an augmented mutation testing process, with starts and ends with dependence analysis phases. The pre-analysis removes a class of equivalent mutants from further analysis, while the post-analysis phase is used to simplify the human effort required to study the few mutants that evade the automated phases of the process.",
      "keywords": "",
      "references": [
        12,
        18,
        20
      ]
    },
    {
      "id": 23,
      "title": "Parallel Firm Mutation of Java Programs",
      "abstract": "Firm mutation was introduced as an intermediate form of mutation testing representing the middle ground between weak and strong mutation. In firm mutation, components may be groups of statements and partial program executions may be considered rather than each separate component execution as in weak mutation or the complete program execution as in strong mutation. Despite its flexibility and its potential for combining the reduced expense of weak mutation with the greater transparency of strong mutation, firm mutation has remained largely unexplored One of the difficulties with firm mutation is that there has been no obvious systematic basis on which to select the areas of program code as candidates for firm mutation testing. The advent of object-oriented languages has, in a sense, provided a natural solution to this problem. The individual methods that form part of object classes tend to be small but cohesive components that lend themselves ideally to firm mutation. This paper considers such application of firm mutation to Java methods by exploiting the use of Java threads to perform mutant execution. The potential parallelism that this affords is another factor in the cost reduction envisaged",
      "keywords": "Firm mutation, object-oriented methods,Java threads, parallelism. ",
      "references": [
        4,
        6,
        8,
        9,
        10,
        11,
        13,
        21
      ]
    },
    {
      "id": 24,
      "title": "Toward the Determination of Sufficient Mutant Operators for C",
      "abstract": "Mutation testing (MT) has been found to be effective at revealing faults. However, its high cost of application, due to the high number of mutants created and the effort to determine the equivalent ones, has motivated the proposition of alternative approaches for its application. One of them, named 'selective mutation', aims to reduce the number of generated mutants through a reduction in the number of mutant operators. A previous relevant study resulted in the proposition of a sufficient mutant operators set for FORTRAN, indicating that it is possible to have a large cost reduction in MT application, whilst preserving a high MT score. This work investigates procedures for the determination of a sufficient mutant operators set for C programs with the perspective of contributing to the establishment of low-cost, effective mutation-based testing strategies.",
      "keywords": "Mutation testing; Software testing; Sufficient mutant operators",
      "references": [
        8,
        15,
        16,
        17,
        21,
        25,
        84
      ]
    },
    {
      "id": 25,
      "title": "Unit and Integration Testing Strategies for C Programs Using Mutation",
      "abstract": " Mutation testing, originally proposed for unit testing, has been extended to integration testing with the proposition of the Interface Mutation criterion. This paper presents the results of an experiment using two mutation-based testing criteria for unit and integration testing phases: the Mutation Analysis and the Interface Mutation adequacy criteria, respectively. The aim is to investigate how they can be used in a complementary way during the testing activity, establishing an incremental testing strategy comprising the unit and integration testing phases and guidelines on how to obtain a high mutation score with respect to mutation testing with a low cost, in terms of the number of mutants generated.",
      "keywords": "Incremental testing strategy; Integration testing; Interface mutation; Mutation analysis; Unit testing",
      "references": [
        8,
        15,
        16,
        17,
        21,
        24
      ]
    },
    {
      "id": 26,
      "title": "Mutation of Java Objects",
      "abstract": " Fault insertion based techniques have been used for measuring test adequacy and testability of programs. Mutation analysis inserts faults into a program with the goal of creating mutation-adequate test sets that distinguish the mutant from the original program. Software testability is measured by calculating the probability that a program will fail on the next test input coming from a predefined input distribution, given that the software includes a fault. Inserted faults must represent plausible errors. It is relatively easy to apply standard transformations to mutate scalar values such as integers, floats, and character data, because their semantics are well understood. Mutating objects that are instances of user defined types is more difficult. There is no obvious way to modify such objects in a manner consistent with realistic faults, without writing custom mutation methods for each object class. We propose a new object mutation approach along with a set of mutation operators and support tools for inserting faults into objects that instantiate items from common Java libraries heavily used in commercial software as well as user defined classes. Preliminary evaluation of our technique shows that it should be effective for evaluating real-world software testing suites. ",
      "keywords": "Faults, Java, mutation analysis, objectoriented programming, software testing, test adequacy, testability",
      "references": []
    },
    {
      "id": 27,
      "title": "Bayesian-Learning Based Guidelines to Determine Equivalent Mutants",
      "abstract": " Mutation testing (Mutation Analysis), although powerful in revealing faults, is considered a computationally expensive criterion, due to the high number of mutants created and the effort to determine the equivalent mutants. Using mutation-based alternative testing criteria it is possible to reduce the number of mutants but it is still necessary to determine the equivalent ones. In this paper the Bayesian Learning (one of the Artificial Intelligence techniques used in machine learning) is investigated to define the Bayesian Learning-Based Equivalent Detection Technique (BaLBEDeT), which provides guidelines to help the tester to analyze the live mutants in order to determine the equivalent ones.",
      "keywords": "Mutation testing; program equivalence analysis; Bayesian learning.",
      "references": [
        8,
        12,
        16,
        17,
        18,
        20,
        21,
        24,
        25
      ]
    },
    {
      "id": 28,
      "title": "How to Overcome the Equivalent Mutant Problem and Achieve Tailored Selective Mutation Using Co-evolution",
      "abstract": " The use of Genetic Algorithms in evolution of mutants and test cases offers new possibilities in addressing some of the main problems of mutation testing. Most specifically the problem of equivalent mutant detection, and the problem of the large number of mutants produced. In this paper we describe the above problems in detail and introduce a new methodology based on co-evolutionary search techniques using Genetic Algorithms in order to address them effectively. Co-evolution allows the parallel evolution of mutants and test cases. We discuss the advantages of this approach over other existing mutation testing techniques, showing details of some initial experimental results carried out.",
      "keywords": "  Genetic Algorithm, Mutation Operator, Software Test, Mutation Testing, Original Program",
      "references": [
        6,
        7,
        9,
        12,
        18,
        20,
        21,
        54
      ]
    },
    {
      "id": 29,
      "title": "From Genetic to Bacteriological Algorithms for Mutation-Based Testing",
      "abstract": " The level of confidence in a software component is often linked to the quality of its test cases. This quality can in turn be evaluated with mutation analysis: faults are injected into the software component (making mutants of it) to check the proportion of mutants detected ('killed') by the test cases. But while the generation of a set of basic test cases is easy, improving its quality may require prohibitive effort. This paper focuses on the issue of automating the test optimization. The application of genetic algorithms would appear to be an interesting way of tackling it. The optimization problem is modelled as follows: a test case can be considered as a predator while a mutant program is analogous to a prey. The aim of the selection process is to generate test cases able to kill as many mutants as possible, starting from an initial set of predators, which is the test cases set provided by the programmer. To overcome disappointing experimentation results, on. Net components and unit Eiffel classes, a slight variation on this idea is studied, no longer at the 'animal' level (lions killing zebras, say) but at the bacteriological level. The bacteriological level indeed better reflects the test case optimization issue: it mainly differs from the genetic one by the introduction of a memorization function and the suppression of the crossover operator. The purpose of this paper is to explain how the genetic algorithms have been adapted to fit with the issue of test optimization. The resulting algorithm differs so much from genetic algorithms that it has been given another name: bacteriological algorithm. ",
      "keywords": "automatic test generation; evolutionist algorithms; object-oriented testing; mutation analysis",
      "references": []
    },
    {
      "id": 30,
      "title": "MuJava: An Automated Class Mutation System",
      "abstract": " Several module and class testing techniques have been applied to object-oriented (OO) programs but researchers have only recently begun developing test criteria that evaluate the use of key OO features such as inheritance, polymorphism, and encapsulation. Mutation testing is a powerful testing technique for generating software tests and evaluating the quality of software. However, the cost of mutation testing has traditionally been so high that it cannot be applied without full automated tool support. This paper presents a method to reduce the execution cost of mutation testing for OO programs by using two key technologies, mutant schemata generation (MSG) and bytecode translation. This method adapts the existing MSG method for mutants that change the program behaviour and uses bytecode translation for mutants that change the program structure. A key advantage is in performance: only two compilations are required and both the compilation and execution time for each is greatly reduced. A mutation tool based on the MSG/bytecode translation method has been built and used to measure the speedup over the separate compilation approach. Experimental results show that the MSG/bytecode translation method is about five times faster than separate compilation. ",
      "keywords": "object-oriented programs; mutation testing; software testing",
      "references": [
        3,
        4,
        5,
        6,
        8,
        13,
        14,
        15,
        17,
        26
      ]
    },
    {
      "id": 31,
      "title": "An Approach to Test Data Generation for Killing Multiple Mutants",
      "abstract": " Software testing is an important technique for assurance of software quality. Mutation testing has been identified as a powerful fault-based technique for unit testing, and there has been some research on automatic generation of test data for mutation testing. However, existing approaches to this kind of test data generation usually generate test data according to one mutant at one time. Thus, more test data that are needed for achieving a given mutation score. In this paper, we propose a new approach to generating one test data according to multiple mutants that are mutated at the same location at one time. Thus, our approach can generate smaller test suite that can achieve the same mutation testing score. To evaluate our approach, we implemented a prototype tool based on our approach and carried out some preliminary experiments. The experimental results show that our approach is more cost-effective.",
      "keywords": "unit testing, mutation testing, test data generation, adequacy criterion",
      "references": [
        7,
        15,
        18
      ]
    },
    {
      "id": 32,
      "title": "Finding Sufficient Mutation Operators via Variable Reduction",
      "abstract": "A set of mutation operators is \"sufficient\" if it can be used for most purposes to replace a larger set. We describe in detail an experimental procedure for determining a set of sufficient C language mutation operators. We also describe several statistical analyses that determine sufficient subsets with respect to several different criteria, based on standard techniques for variable reduction. We have begun to carry out our experimental procedure on seven standard C subject programs. We present preliminary results that indicate that the procedure and analyses are feasible and yield useful information. ",
      "keywords": "",
      "references": [
        17,
        25,
        30
      ]
    },
    {
      "id": 33,
      "title": "The Class-Level Mutants of MuJava",
      "abstract": " This paper presents results from empirical studies of object-oriented, class level mutation operators, using the automated analysis and testing tool MuJava. Class mutation operators modify OO programming language features such as inheritance, polymorphism, dynamic binding and encapsulation. This paper presents data from 866 classes in six open-source programs. Several new class-level mutation operators are defined in this paper and an analysis of the number of mutants generated is provided. Techniques for eliminating some equivalent mutants are described and data from an automated tool are provided. One important result is that class-level mutation operators yield far more equivalent mutants than traditional, statement-level, operators. Another is that there are far fewer class-level mutants than statement-level mutants. Together, these data suggest that mutation for inter-class testing can be practically affordable. ",
      "keywords": "",
      "references": [
        12,
        17,
        20,
        30
      ]
    },
    {
      "id": 34,
      "title": "Automatic Mutation Test Input Data Generation via Ant Colony",
      "abstract": " Fault-based testing is often advocated to overcome limitations ofother testing approaches; however it is also recognized as beingexpensive. On the other hand, evolutionary algorithms have beenproved suitable for reducing the cost of data generation in the contextof coverage based testing. In this paper, we propose a newevolutionary approach based on ant colony optimization for automatictest input data generation in the context of mutation testingto reduce the cost of such a test strategy. In our approach the antcolony optimization algorithm is enhanced by a probability densityestimation technique. We compare our proposal with otherevolutionary algorithms, e.g., Genetic Algorithm. Our preliminaryresults on JAVA testbeds show that our approach performed significantlybetter than other alternatives.",
      "keywords": "Test input data generation, Search based testing, Mutation testing,Ant colony optimization.",
      "references": [
        9,
        21,
        28
      ]
    },
    {
      "id": 35,
      "title": "Aspect-oriented Response Injection: an Alternative to Classical Mutation Testing",
      "abstract": " Due to increasing importance of test cases in software development, there is a need to verify and assure their quality. Mutation testing is an effective technique of checking if tests react properly to changes by introducing alterations to the original source code. A mutant which survives all test cases indicates insufficient or inappropriate testing assertions. The most onerous disadvantage of this technique is considerable time required to generate, compile mutants and then execute test cases against each of them. In the paper we propose an aspect-oriented approach to generation and execution of mutants, called response injection, which excludes the need for separate compilation of every mutant. \u00a9 2006 International Federation for Information Processing.",
      "keywords": "",
      "references": [
        30
      ]
    },
    {
      "id": 36,
      "title": "Mutating database queries",
      "abstract": " A set of mutation operators for SQL queries that retrieve information from a database is developed and tested against a set of queries drawn from the NIST SQL Conformance Test Suite. The mutation operators cover a wide spectrum of SQL features, including the handling of null values. Additional experiments are performed to explore whether the cost of executing mutants can be reduced using selective mutation or the test suite size can be reduced by using an appropriate ordering of the mutants. The SQL mutation approach can be helpful in assessing the adequacy of database test cases and their development, and as a tool for systematically injecting faults in order to compare different database testing techniques. ",
      "keywords": "Software testing; Database testing; SQL testing; Fault-based testing; Mutation testing; Test adequacy criteria",
      "references": [
        17,
        30
      ]
    },
    {
      "id": 37,
      "title": "Automated Generation of Pointcut Mutants for Testing Pointcuts in AspectJ Programs",
      "abstract": " Aspect-Oriented Programming (AOP) provides new modularization of software systems by encapsulating cross- cutting concerns. AspectJ, an AOP language, uses ab- stractions such as pointcuts, advice, and aspects to achieve AOP's primary functionality. Faults in pointcuts can cause aspects to fail to satisfy their requirements. Hence, test- ing pointcuts is necessary in order to ensure correctness of aspects. In mutation testing of pointcuts (a type of fault- based pointcut testing), the number of mutants (i.e., varia- tions) for pointcuts is usually large due to the usage of wild- cards. It is tedious to manually identify effective mutants that are of appropriate strength and resemble closely the original pointcut expression, reflecting the kind of mistakes that developers may make. To reduce developers' effort in this process, we have developed a new framework that au- tomatically identifies the strength of each pointcut and gen- erates pointcut mutants with different strengths. Develop- ers can inspect the pointcut mutants and their join points for pointcut correctness or choose the mutants for conduct- ing mutation testing. We conducted an empirical study on applying our framework on pointcuts from existing AspectJ programs. The results show that our framework can pro- vide valuable assistance in generating effective mutants that re close to the original pointcuts and are of appropriate strength.",
      "keywords": "",
      "references": []
    },
    {
      "id": 38,
      "title": "Sufficient Mutation Operators for Measuring Test Effectiveness",
      "abstract": " Mutants are automatically-generated, possibly faulty variants of programs. The mutation adequacy ratio of a test suite is the ratio of non-equivalent mutants it is able to identify to the total number of non-equivalent mutants. This ratio can be used as a measure of test effectiveness. However, it can be expensive to calculate, due to the large number of different mutation operators that have been proposed for generating the mutants. In this paper, we address the problem of finding a small set of mutation operators which is still sufficient for measuring test effectiveness. We do this by defining a statistical analysis procedure that allows us to identify such a set, together with an associated linear model that predicts mutation adequacy with high accuracy. We confirm the validity of our procedure through cross-validation and the application of other, alternative statistical analyses. ",
      "keywords": "Mutation analysis, testing effectiveness",
      "references": [
        17,
        24,
        30,
        32,
        36
      ]
    },
    {
      "id": 39,
      "title": "GAmera: An Automatic Mutant Generation System for WS-BPEL Compositions",
      "abstract": " Business processes based in WS-BPEL compositions are rapidly becoming commonplace in recent years, so it is important to pay special attention to testing in this context. Mutation testing is a white-box testing technique that has been applied successfully to programs written in several languages. In order to apply it we need a system for mutant generation. This paper presents the first results of applying a new system, GAmera, for automatic mutant generation for WS-BPEL compositions. It is composed by three different elements: an analyzer, a mutant generator and a system that executes and evaluates the mutants. GAmera is based in genetic algorithms and attempts to minimize the number of generated mutants, independently of the number and type of mutation operators, without losing relevant information. It can also detect potentially equivalent mutants allowing to improve the quality of the test suite.",
      "keywords": "Web Services; Web Service compositions; WS-BPEL; Genetic Algorithms; Mutation testing",
      "references": [
        28,
        30,
        36
      ]
    },
    {
      "id": 40,
      "title": "A Novel Method of Mutation Clustering Based on Domain Analysis",
      "abstract": " Mutation testing is an effective but expensive technique. There exists much improvement to help mutation testing become a wide-used technique. The main objective is to reduce the number of mutants and the reduced test sets can still approximate the adequacy. Recently a new method, called mutation clustering, is proposed to integrate data clustering and mutation analysis, such that both mutant sets and test sets can be reduced dramatically. This paper provides domain analysis to cluster mutants statically before test case generation. And then the simplified mutant set is used to generate a test set. We hypothesize that such a test set can kill the original mutant set approximately. The cost of mutation testing will further decrease, because only a small test set needs to be generated and executed. A case study shows an encouraging result to support our hypothesis.",
      "keywords": "",
      "references": [
        8,
        14,
        15,
        17
      ]
    },
    {
      "id": 41,
      "title": "Using a Fault Hierarchy to Improve the Efficiency of DNF Logic Mutation Testing",
      "abstract": " Mutation testing is a technique for generating high quality test data. However, logic mutation testing is currently inefficient for three reasons. One, the same mutant is generated more than once. Two, mutants are generated that are guaranteed to be killed by a test that kills some other generated mutant. Three, mutants that when killed are guaranteed to kill many other mutants are not generated as valuable mutation operators are missing. This paper improves logic mutation testing by 1) extending a logic fault hierarchy to include existing logic mutation operators, 2) introducing new logic mutation operators based on existing faults in the hierarchy, 3) introducing new logic mutation operators having no corresponding faults in the hierarchy and extending the hierarchy to include them, and 4) addressing the precise effects of equivalent mutants on the fault hierarchy. An empirical study using minimal DNF predicates in avionics software showed that a new logic mutation testing approach generates fewer mutants, detects more faults, and outperforms an existing logic criterion.",
      "keywords": "Software Logic Testing, Mutation Testing,Test Criteria, Disjunctive Normal Form, MUMCUT",
      "references": [
        8,
        12,
        13,
        18,
        20
      ]
    },
    {
      "id": 42,
      "title": "An Effective Path Selection Strategy for Mutation Testing",
      "abstract": " Mutation testing has been identified as one of the most effective techniques, in detecting faults. However, because of the large number of test elements that it introduces, it is regarded as rather expensive for practical use. Therefore, there is a need for testing strategies that will alleviate this drawback by selecting effective test data that will make the technique more practical. Such a strategy based on path selection is reported in this paper. A significant influence on the efficiency associated with path selection strategies is the number of test paths that must be generated in order to achieve a specified level of coverage, and it is determined by the number of paths that are found to be feasible. Specifically, a path selection strategy is proposed that aims at reducing the effects of infeasible paths and conversely developing effective and efficient mutation based tests. The results obtained from applying the method to a set of program units are reported and analysed presenting the flexibility, feasibility and practicality of the proposed approach. ",
      "keywords": "software testing, unit testing, mutation testing,path testing, adequacy criterion, infeasible paths",
      "references": [
        13,
        17,
        43,
        45
      ]
    },
    {
      "id": 43,
      "title": "Efficient Mutation Testing by Checking Invariant Violations",
      "abstract": " Mutation testing measures the adequacy of a test suite by seeding artificial defects (mutations) into a rogram. If a mutation is not detected by the test suite, this usually means that the test suite is not adequate. However, it may also be that the mutant kee s the rogram's semantics unchanged| and thus cannot be detected by any test. Such equivalent mutants have to be eliminated manually, which is tedious. We assess the im act of mutations by checking dynamic invariants. In an evaluation of our JAVALANCHE framework on seven industrial-size rograms, we found that mutations that violate invariants are significantly more likely to be detectable by a test suite. As a consequence, mutations with im act on invariants should be focused u on when im roving test suites. With less than 3% of equivalent mutants, our a roach rovides an efficient, recise, and fully automatic measure of the adequacy of a test suite. ",
      "keywords": "Dynamic Invariants, Mutation Testing",
      "references": [
        9,
        12,
        17,
        20,
        28,
        38
      ]
    },
    {
      "id": 44,
      "title": "On Reduced Neighborhood Mutation Analysis Using a Single Mutagenic Operator",
      "abstract": "Mutation analysis evaluates the quality of a test suite based on its ability to reveal simple faults, termed mutations, injected in the program under test. Unfortunately, the need to execute many slightly different versions, or mutants, of a program makes mutation analysis a computationally expensive technique. This paper reports on a promising approach that reduces the cost of mutation analysis by reducing the number of mutants that need to be executed.",
      "keywords": "software testing, mutation analysis, constrained mutation,sufficient mutant operators, reduced neighborhood mutation",
      "references": [
        2,
        8,
        15,
        17,
        20,
        32,
        38,
        84
      ]
    },
    {
      "id": 45,
      "title": "Decreasing the Cost of Mutation Testing with Second-Order Mutants",
      "abstract": " Although powerful, mutation is a computationally very expensive testing technique. In fact, its three main stages (mutant generation, mutant execution and result analysis) require many resources to be successfully accomplished. Thus, researchers have made important efforts to reduce its costs. This paper represents an additional effort in this sense. It describes the results of two experiments in which, by means of combining the original set of mutants and therefore obtaining a new set of mutants - each one with two faults - the number of mutants used is reduced to half. Results lead to believe that mutant combination does not decrease the quality of the test suite, whereas it supposes important savings in mutant execution and result analysis.",
      "keywords": "mutation; cost reduction; mutant reduction",
      "references": [
        3,
        4,
        6,
        10,
        12,
        13,
        15,
        17,
        18,
        21,
        29,
        30
      ]
    },
    {
      "id": 46,
      "title": "MuTMuT: Efficient Exploration for Mutation Testing of Multithreaded Code",
      "abstract": " Mutation testing is a method for measuring the quality of test suites. Given a system under test and a test suite, mutations are systematically inserted into the system, and the test suite is executed to determine which mutants it detects. A major cost of mutation testing is the time required to execute the test suite on all the mutants. This cost is even greater when the system under test is multithreaded: not only are test cases from the test suite executed on many mutants, but also each test case is executed for multiple possible thread schedules. We introduce a general framework that can reduce the time for mutation testing of multithreaded code. We present four techniques within the general framework and implement two of them in a tool called MuTMuT. We evaluate MuTMuT on eight multithreaded programs. The results show that MuTMuT reduces the time for mutation testing, substantially over a straightforward mutant execution and up to 77% with the advanced technique over the basic technique. ",
      "keywords": "",
      "references": [
        9,
        11,
        43
      ]
    },
    {
      "id": 47,
      "title": "Evaluating Mutation Testing Alternatives: A Collateral Experiment",
      "abstract": " Mutation testing while being a successful fault revealing technique for unit testing, it is a rather expensive one for practical use. To bridge these two aspects there is a need to establish approximation techniques able to reduce its expenses while maintaining its effectiveness. In this paper several second order mutation testing strategies are introduced, assessed and compared along with weak mutation against strong. The experimental results suggest that they both constitute viable alternatives for mutation as they establish considerable effort reductions without greatly affecting the test effectiveness. The experimental assessment of weak mutation suggests that it reduces significantly the number of the produced equivalent mutants on the one hand and that the test criterion it provides is not as weak as is thought to be on the other. Finally, an approximation of the number of first order mutants needed to be killed in order to also kill the original mutant set is presented. The findings indicate that only a small portion of a set of mutants needs to be targeted in order to be killed while the rest can be killed collaterally.",
      "keywords": "mutation testing; higher order mutation; weak mutation; collateral coverage",
      "references": [
        13,
        17,
        20,
        30,
        42,
        45,
        48,
        52
      ]
    },
    {
      "id": 48,
      "title": "An Empirical Evaluation of the First and Second Order Mutation Testing Strategies",
      "abstract": " Various mutation approximation techniques have been proposed in the literature in order to reduce the expenses of mutation. This paper presents results from an empirical study conducted for first and second order mutation testing strategies. Its scope is to evaluate the relative application cost and effectiveness of the different mutation strategies. The application cost was based: on the number of mutants, the equivalent ones and on the number of test cases needed to expose them by each strategy. Each strategy's effectiveness was evaluated by its ability to expose a set of seeded faults. The results indicate that on the one hand the first order mutation testing strategies can be in general more effective than the second order ones. On the other hand, the second order strategies can drastically decrease the number of the introduced equivalent mutants, generally forming a valid cost effective alternative to mutation testing.",
      "keywords": "mutation testing, higher order mutation",
      "references": [
        13,
        17,
        21,
        24,
        38,
        42,
        45
      ]
    },
    {
      "id": 49,
      "title": "Automatic Mutation Test Case Generation via Dynamic Symbolic Execution",
      "abstract": " The automatic test case generation is the principal issue of the software testing activity. Dynamic symbolic execution appears to be a promising approach to this matter as it has been shown to be quite powerful in producing the sought tests. Despite its power, it has only been effectively applied to the entry level criteria of the structural criteria hierarchy such as branch testing. In this paper an extension of this technique is proposed in order to effectively generate test data based on mutation testing. The proposed approach conjoins program transformation and dynamic symbolic execution techniques in order to successfully automate the test generation process. The propositions made in this paper have been incorporated into an automated framework for producing mutation based test cases. Its evaluation on a set of benchmark programs suggests that it is able to produce tests capable of killing most of the non equivalent introduced mutants. The same study also provides some evidence that by employing efficient heuristics it can be possible to perform mutation with reasonable resources. ",
      "keywords": "automated test case generation, dynamic symbolic execution, mutation testing, mutant schemata",
      "references": [
        9,
        15,
        17,
        18,
        30,
        34,
        42,
        53
      ]
    },
    {
      "id": 50,
      "title": "Prioritizing Mutation Operators based on Importance Sampling",
      "abstract": " Mutation testing is a fault-based testing technique for measuring the adequacy of a test suite. Test suites are assigned scores based on their ability to expose synthetic faults (i.e., mutants) generated by a range of well-defined mathematical operators. The test suites can then be augmented to expose the mutants that remain undetected and are not semantically equivalent to the original code. However, the mutation score can be increased superfluously by mutants that are easy to expose. In addition, it is infeasible to examine all the mutants generated by a large set of mutation operators. Existing approaches have therefore focused on determining the sufficient set of mutation operators and the set of equivalent mutants. Instead, this paper proposes a novel Bayesian approach that prioritizes operators whose mutants are likely to remain unexposed by the existing test suites. Probabilistic sampling methods are adapted to iteratively examine a subset of the available mutants and direct focus towards the more informative operators. Experimental results show that the proposed approach identifies more than 90% of the important operators by examining \u2264 20% of the available mutants, and causes a 6% increase in the importance measure of the selected mutants.",
      "keywords": "Mutation Testing; Testing Effectiveness; Impor-\ntance Sampling; Bayesian Reasoning.",
      "references": [
        17,
        20,
        30,
        32,
        38,
        43,
        44
      ]
    },
    {
      "id": 51,
      "title": "From Behaviour Preservation to Behaviour Modification: Constraint-Based Mutant Generation",
      "abstract": " The efficacy of mutation analysis depends heavily on its capability to mutate programs in such a way that they remain executable and exhibit deviating behaviour. Whereas the former requires knowledge about the syntax and static semantics of the programming language, the latter requires some least understanding of its dynamic semantics, i.e., how expressions are evaluated. We present an approach that is knowledgeable enough to generate only mutants that are both syntactically and semantically correct and likely exhibit non-equivalent behaviour. Our approach builds on our own prior work on constraint-based refactoring tools, and works by negating behaviour-preserving constraints. As a proof of concept we present an enhanced implementation of the Access Modifier Change operator for Java programs whose naive implementations create huge numbers of mutants that do not compile or leave behaviour unaltered. While we cannot guarantee that our generated mutants are non-equivalent, we can demonstrate a considerable reduction in the number of vain mutant generations, leading to substantial temporal savings.",
      "keywords": "Mutation Analysis, Refactoring, Testing, Accessibility, Constraints, Object-Oriented Programming.",
      "references": [
        12,
        18,
        20,
        22,
        33,
        43
      ]
    },
    {
      "id": 52,
      "title": "Is Operator-Based Mutant Selection Superior to Random Mutant Selection?",
      "abstract": " Due to the expensiveness of compiling and executing a large number of mutants, it is usually necessary to select a subset of mutants to substitute the whole set of generated mutants in mutation testing and analysis. Most existing research on mutant selection focused on operator-based mutant selection, i.e., determining a set of sufficient mutation operators and selecting mutants generated with only this set of mutation operators. Recently, researchers began to leverage statistical analysis to determine sufficient mutation operators using execution information of mutants. However, whether mutants selected with these sophisticated techniques are superior to randomly selected mutants remains an open question. In this paper, we empirically investigate this open question by comparing three representative operator-based mutant-selection techniques with two random techniques. Our empirical results show that operator-based mutant selection is not superior to random mutant selection. These results also indicate that random mutant selection can be a better choice and mutant selection on the basis of individual mutants is worthy of further investigation",
      "keywords": "Mutation testing, Test-adequacy criterion",
      "references": [
        3,
        5,
        12,
        15,
        17,
        18,
        20,
        24,
        30,
        31,
        36,
        38,
        43
      ]
    },
    {
      "id": 53,
      "title": "Test Generation via Dynamic Symbolic Execution for Mutation Testing",
      "abstract": " Mutation testing has been used to assess and improve the quality of test inputs. Generating test inputs to achieve high mutant-killing ratios is important in mutation testing. However, existing test-generation techniques do not provide effective support for killing mutants in mutation testing. In this paper, we propose a general test-generation approach, called PexMutator, for mutation testing using Dynamic Symbolic Execution (DSE), a recent effective test-generation technique. Based on a set of transformation rules, PexMutator transforms a program under test to an instrumented meta-program that contains mutant-killing constraints. Then PexMutator uses DSE to generate test inputs for the meta-program. The mutant-killing constraints introduced via instrumentation guide DSE to generate test inputs to kill mutants automatically. We have implemented our approach as an extension for Pex, an automatic structural testing tool developed at Microsoft Research. Our preliminary experimental study shows that our approach is able to strongly kill more than 80% of all the mutants for the five studied subjects. In addition, PexMutator is able to outperform Pex, a state-of-theart test-generation tool, in terms of strong mutant killing while achieving the same block coverage. ",
      "keywords": "",
      "references": [
        8,
        9,
        15,
        17,
        18,
        20,
        21,
        31,
        43,
        52
      ]
    },
    {
      "id": 54,
      "title": "Evolutionary Mutation Testing",
      "abstract": " Context: Mutation testing is a testing technique that has been applied successfully to several programming languages. However, it is often regarded as computationally expensive, so several refinements have been proposed to reduce its cost. Moreover, WS-BPEL compositions are being widely adopted by developers, but present new challenges for testing, since they can take much longer to run than traditional programs of the same size. Therefore, it is interesting to reduce the number of mutants required. Objective: We present Evolutionary Mutation Testing (EMT), a novel mutant reduction technique for finding mutants that help derive new test cases that improve the quality of the initial test suite. It uses evolutionary algorithms to reduce the number of mutants that are generated and executed with respect to the exhaustive execution of all possible mutants, keeping as many difficult to kill and potentially equivalent mutants (strong mutants) as possible in the reduced set. Method: To evaluate EMT we have developed GAmera, a mutation testing system powered by a co-evolutive genetic algorithm. We have applied this system to three WS-BPEL compositions to estimate its effectiveness, comparing it with random selection. Results: The results obtained experimentally show that EMT can select all strong mutants generating 15% less mutants than random selection in over 20% less time for complex compositions. When generating a percentage of all mutants, EMT finds on average more strong mutants than random selection. This has been confirmed to be statistically significant within a 99.9% confidence interval. Conclusions: EMT has reduced for the three tested compositions the number of mutants required to select those which are useful to derive new test cases that improve the quality of the test suite. The directed search performed by EMT makes it more effective than random selection, especially as compositions become more complex and the search space widens. ",
      "keywords": " Mutation testing , Evolutionary algorithm, Genetic algorithm, Web Service,WS-BPEL",
      "references": [
        3,
        4,
        5,
        6,
        8,
        9,
        17,
        28,
        30,
        33,
        36,
        39
      ]
    },
    {
      "id": 55,
      "title": "An Analysis of OO Mutation Operators",
      "abstract": " This paper presents results from empirical studies using object-oriented, class-level mutation operators. Class mutation operators modify OO programming language features such as inheritance, polymorphism, dynamic binding and encapsulation. Most previous empirical studies of mutation operators used statement-level operators; this study asked questions about the static and dynamic nature of class-level mutation operators. Results include statistics on the various types of mutants, how many are equivalent, new rules for avoiding creation of equivalent mutants, the difficulty of killing individual mutants, and the difficulty of killing mutants from the various operators. The paper draws conclusions about which mutation operators are more or less useful, leading to recommendations about how future OO mutation systems should be built. ",
      "keywords": "",
      "references": [
        12,
        17,
        20,
        30,
        33
      ]
    },
    {
      "id": 56,
      "title": "Using Conditional Mutation to Increase the Efficiency of Mutation Analysis",
      "abstract": " Assessing testing strategies and test sets is a crucial part of software testing. Mutation analysis is, among other approaches, a suitable technique for this purpose. However, compared with other methods it is rather time-consuming and applying mutation analysis to large software systems is still problematic. This paper presents a versatile approach, called conditional mutation, which increases the efficiency of mutation analysis. This new method significantly reduces the time overhead for generating and executing the mutants. Results are reported for eight investigated programs up to 373,000 lines of code and 406,000 generated mutants. Furthermore, conditional mutation has been integrated into the Java 6 Standard Edition compiler. Thus, it is widely applicable and not limited to a certain testing tool or framework.",
      "keywords": "Mutation Analysis, Instrumentation, Compiler-integrated",
      "references": [
        3,
        9,
        17,
        18,
        38
      ]
    },
    {
      "id": 57,
      "title": "Reducing Logic Test Set Size while Preserving Fault Detection",
      "abstract": " Logic criteria demand inputs that guarantee detection of certain faults. One such criterion, MUMCUT, is composed of three criteria, where each constituent criterion ensures the detection of specific faults. In practice, the criteria may overlap in terms of faults detected, leading to redundant tests, but due to the fact that infeasible requirements do not result in tests, all the constituent criteria are needed. The key insight of this paper is that analysis of the feasibility of the constituent criteria can reduce test set size without sacrificing fault detection for specific faults. This paper introduces a new logic criterion, Minimal-MUMCUT, and shows how it can apply to minimal DNF, minimal CNF, and general form Boolean expressions. With Minimal-MUMCUT, a determination is made of which constituent criteria are feasible, and hence necessary, at the level of individual literals and terms. An empirical study found that Minimal-MUMCUT reduces the test set size, without sacrificing fault detection, regardless of the predicate format. ",
      "keywords": "software logic testing; logic criteria; MUMCUT; disjunctive normal form; fault coupling",
      "references": [
        18,
        45
      ]
    },
    {
      "id": 58,
      "title": "A Logic Mutation Approach to Selective Mutation for Programs and Queries",
      "abstract": " Context: Program mutation testing is a technique for measuring and generating high quality test data. However, traditional mutation operators are not necessarily efficient or effective. We address three specific issues. One, test data that kills all mutants generated by current mutation tools can still miss detection of some common logic faults because such tools lack appropriate logic mutation operators. Two, the number of mutants generated is often unnecessarily large. Three, many equivalent mutants can be generated and these can be difficult to eliminate. Objective: This paper explores the idea of addressing these issues by selectively generating only specially engineered subsuming higher order logic mutants. However, such an approach is only useful if a test set that kills all such mutants also kills a high percentage of general mutants. Method: An empirical study was conducted using a tool that generates only subsuming higher order logic mutants and tools that generate general mutants. Both Java code and SQL were used as the source under test. Results and conclusions: For both the software and queries, tests killing all the subsuming higher order mutants killed a high percentage of general mutants while reducing both the number of mutants and the number of equivalent mutants. The conclusion is that, for the test subjects studied, subsuming higher order logic mutation is an effective approach to selective mutation for programs and queries.",
      "keywords": "Software logic testing,Mutation testing,Database query testing,Disjunctive Normal Form",
      "references": [
        8,
        12,
        13,
        17,
        18,
        20,
        30,
        36,
        41,
        45
      ]
    },
    {
      "id": 59,
      "title": "Automatic Mutation based Test Data Generation",
      "abstract": " This paper proposes a search based test data generation approach for mutation testing. The proposed approach uses a novel dynamic execution scheme in order to both introduce mutants and to effectively guide the search process towards generating test cases able to kill those mutants. A novel fitness function and its integration with a dynamically adjusted mechanism are also proposed. Preliminary experimentation with a hill climbing search based approach reveals its power when compared against a previously proposed one and random testing.",
      "keywords": "Test input data generation, Search based testing, Mutation testing",
      "references": [
        17,
        34,
        49,
        63
      ]
    },
    {
      "id": 60,
      "title": "Automatically Performing Weak Mutation with the Aid of Symbolic Execution, Concolic Testing and Search-based Testing",
      "abstract": " Automating software testing activities can increase the quality and drastically decrease the cost of software development. Toward this direction, various automated test data generation tools have been developed. The majority of existing tools aim at structural testing, while a quite limited number aim at a higher level of testing thoroughness such as mutation. In this paper, an attempt toward automating the generation of mutation-based test cases by utilizing existing automated tools is proposed. This is achieved by reducing the killing mutants' problem into a covering branches one. To this extent, this paper is motivated by the use of state of the art techniques and tools suitable for covering program branches when performing mutation. Tools and techniques such as symbolic execution, concolic execution, and evolutionary testing can be easily adopted toward automating the test input generation activity for the weak mutation testing criterion by simply utilizing a special form of the mutant schemata technique. The propositions made in this paper integrate three automated tools in order to illustrate and examine the method's feasibility and effectiveness. The obtained results, based on a set of Java program units, indicate the applicability and effectiveness of the suggested technique. The results advocate that the proposed approach is able to guide existing automating tools in producing test cases according to the weak mutation testing criterion. Additionally, experimental results with the proposed mutation testing regime show that weak mutation is able to speedup the mutant execution time by at least 4.79 times when compared with strong mutation.",
      "keywords": "Mutation testing , Weak mutation,  Automated test case generation, Mutant schemata, Symbolic execution, Concolic execution , Search-based testing",
      "references": [
        9,
        13,
        17,
        18,
        30,
        34,
        42,
        45,
        48,
        49,
        63
      ]
    },
    {
      "id": 61,
      "title": "Quality Evaluation of Object-Oriented and Standard Mutation Operators Applied to C# Programs",
      "abstract": " Mutation testing is a kind of fault injection approach that can be used to generate tests or to assess the quality of test sets. For object-oriented languages, like C#, both object-oriented and standard (traditional) mutation operators should be applied. The methods that can contribute to reducing the number of applied operators and lowering the costs of mutation testing were experimentally investigated. We extended the CREAM mutation tool to support selective testing, sampling and clustering of mutants, and combining code coverage with mutation testing. We propose an approach to quality evaluation and present experimental results of mutation operators applied to C# programs. ",
      "keywords": "  ",
      "references": [
        8,
        15,
        24,
        30,
        40,
        52,
        55,
        58
      ]
    },
    {
      "id": 62,
      "title": "Toward Harnessing High-Level Language Virtual Machines for Further Speeding Up Weak Mutation Testing",
      "abstract": " High-level language virtual machines (HLL VMs) are now widely used to implement high-level programming languages. To a certain extent, their widespread adoption is due to the software engineering benefits provided by these managed execution environments, for example, garbage collection (GC) and cross-platform portability. Although HLL VMs are widely used, most research has concentrated on high-end optimizations such as dynamic compilation and advanced GC techniques. Few efforts have focused on introducing features that automate or facilitate certain software engineering activities, including software testing. This paper suggests that HLL VMs provide a reasonable basis for building an integrated software testing environment. As a proof-of-concept, we have augmented a Java virtual machine (JVM) to support weak mutation analysis. Our mutation-aware HLL VM capitalizes on the relationship between a program execution and the underlying managed execution environment, thereby speeding up the execution of the program under test and its associated mutants. To provide some evidence of the performance of our implementation, we conducted an experiment to compare the efficiency of our VM-based implementation with a strong mutation testing tool (muJava). Experimental results show that the VM-based implementation achieves speedups of as much as 89% in some cases. ",
      "keywords": "Mutation Analysis; Java Virtual Machine; Software Testing; Maxine VM; muJava.",
      "references": [
        13,
        17,
        30,
        55
      ]
    },
    {
      "id": 63,
      "title": "Mutation-Driven Generation of Unit Tests and Oracles",
      "abstract": " To assess the quality of test suites, mutation analysis seeds artificial defects (mutations) into programs; a nondetected mutation indicates a weakness in the test suite. We present an automated approach to generate unit tests that detect these mutations for object-oriented classes. This has two advantages: First, the resulting test suite is optimized toward finding defects modeled by mutation operators rather than covering code. Second, the state change caused by mutations induces oracles that precisely detect the mutants. Evaluated on 10 open source libraries, our \u03bc test prototype generates test suites that find significantly more seeded defects than the original manually written test suites. ",
      "keywords": "Mutation analysis, test case generation, unit testing, test oracles, assertions, search-based testing.",
      "references": [
        17,
        34,
        38,
        43,
        53
      ]
    },
    {
      "id": 64,
      "title": "Efficient Mutation Testing of Multithreaded Code",
      "abstract": " Mutation testing is a well-established method for measuring and improving the quality of test suites. A major cost of mutation testing is the time required to execute the test suite on all the mutants. This cost is even greater when the system under test is multithreaded: not only are test cases from the test suite executed on many mutants but also each test case is executed\u2014or more precisely, explored\u2014for multiple possible thread schedules. This paper introduces a general framework for efficient exploration that can reduce the time for mutation testing of multithreaded code. The paper presents five techniques (four optimizations and one heuristic) that are implemented in a tool called MuTMuT within the general framework. Evaluation of MuTMuT on mutation testing of 12 multithreaded programs shows that it can substantially reduce the time required for mutation testing of multithreaded code",
      "keywords": "mutation testing; multithreaded code",
      "references": [
        9,
        11,
        17,
        34,
        43,
        46,
        49,
        53,
        63
      ]
    },
    {
      "id": 65,
      "title": "Using Non-Redundant Mutation Operators and Test Suite Prioritization to Achieve Efficient and Scalable Mutation Analysis",
      "abstract": " Mutation analysis is a powerful and unbiased technique to assess the quality of input values and test oracles. However, its application domain is still limited due to the fact that it is a time consuming and computationally expensive method, especially when used with large and complex software systems. Addressing these challenges, this paper makes several contributions to significantly improve the efficiency of mutation analysis. First, it investigates the decrease in generated mutants by applying a reduced, yet sufficient, set of mutants for replacing conditional (COR) and relational (ROR) operators. The analysis of ten real-world applications, with 400,000 lines of code and more than 550,000 generated mutants in total, reveals a reduction in the number of mutants created of up to 37% and more than 25% on average. Yet, since the isolated use of non-redundant mutation operators does not ensure that mutation analysis is efficient and scalable, this paper also presents and experimentally evaluates an optimized workflow that exploits the redundancies and runtime differences of test cases to reorder and split the corresponding test suite. Using the same ten open-source applications, an empirical study convincingly demonstrates that the combination of nonredundant operators and prioritization leveraging information about the runtime and mutation coverage of tests reduces the total cost of mutation analysis further by as much as 65%. ",
      "keywords": "",
      "references": [
        17,
        38,
        43,
        56,
        63
      ]
    },
    {
      "id": 66,
      "title": "Combining Weak and Strong Mutation for a Noninterpretive Java Mutation System",
      "abstract": " Because of the computationally expensive cost of mutation testing, automated system support is indispensable for conducting mutation testing. Mutation systems can be classified into interpretive and noninterpretive, but recent systems are noninterpretive. Weak mutation is a well-known cost reduction method of mutation testing, but it is not directly applicable to noninterpretive mutation systems. To address the problem and take advantage of the efficiency of weak mutation, this paper presents a combined weak and strong mutation for noninterpretive Java mutation systems. The new term 'serialmutant' is defined as a specialized program to conduct weak mutation against all mutants in an execution and report only weakly killed mutants as strong mutation candidates. Then strong mutation is conducted only for those reported mutants. The paper also describes an implementation based on a previous Java mutation tool, MuJava. Method-level mutation operators for Java are also redesigned. Experimental results show that the proposed approach efficiently improves the mutation cost in a noninterpretive mutation system.",
      "keywords": " MuJava; mutation testing; noninterpretive mutation system; weak mutation",
      "references": [
        2,
        3,
        8,
        9,
        10,
        11,
        13,
        14,
        17,
        30
      ]
    },
    {
      "id": 67,
      "title": "Reducing Interface Mutation Costs with Multiobjective Optimization Algorithms",
      "abstract": "To reduce mutation test costs, different strategies were proposed to find a set of essential operators that generates a reduced number of mutants without decreasing the mutation score. However, the operator selection is influenced by other factors, such as: number of test data, execution time, number of revealed faults, etc. In fact this is a multiobjective problem. For that, different good solutions exist. To properly deal with this problem, a selection strategy based on multiobjective algorithms was proposed and investigated for unit testing. This work explores the use of such strategy in the integration testing phase. Three multiobjective algorithms are used and evaluated with real programs: one algorithm based on tabu search (MTabu), one based on Genetic Algorithm (NSGA-II) and the third one based on Ant Colony Optimization (PACO). The results are compared with traditional strategies and contrasted with essential operators obtained in the unit testing level.",
      "keywords": "Ant Colony Optimization, Fault-Based Criteria, Integration Testing, Multiobjective Optimization, Evolutionary Algorithms",
      "references": [
        8,
        15,
        16,
        17,
        24,
        38,
        40,
        45
      ]
    },
    {
      "id": 68,
      "title": "An Exploratory Study of Higher Order Mutation Testing in Aspect-Oriented Programming",
      "abstract": " Higher order mutation testing is a relatively new area of research. Researchers have claimed that higher order mutants have the potential to increase test effectiveness and reduce test effort. However, these claims have not been evaluated in the context of the aspect-oriented programming paradigm, which introduces new and unique concepts and constructs, and consequently new testing challenges. We present an exploratory study of higher order mutation testing in the context of AspectJ, which is the most widely used aspect-oriented programming language. Based on published fault-models, we propose four approaches to constructing higher order mutants in AspectJ programs. We evaluate the approaches in terms of their ability to create higher order mutants that result in higher test effectiveness and lower test effort compared to first order mutants. The approaches (1) insert two faults in a single base class or two faults in a single aspect, (2) insert two faults in two different base classes, (3) insert two faults in two different aspects, and (4) insert one fault in a base class and one in an aspect. We developed a prototype tool that automates the process of generating, compiling, and executing higher order mutants. The first approach produced a larger percentage of higher order mutants that were harder to kill than the constituent first order mutants as compared to the last three approaches. The first approach lowered the total number of mutants to be compiled and executed to a greater extent than the last three approaches. The last three approaches produced a lower density of equivalent mutants but the absolute number of equivalent mutants is greater for higher order mutants than for first order mutants.",
      "keywords": "Higher order mutation testing; equivalent mutant;\naspect-oriented programming; MuJava; AjMutator;",
      "references": [
        30,
        37,
        45,
        48,
        71
      ]
    },
    {
      "id": 69,
      "title": "Mutation Based Test Case Generation Via a Path Selection Strategy",
      "abstract": " Context: Generally, mutation analysis has been identified as a powerful testing method. Researchers have shown that its use as a testing criterion exercises quite thoroughly the system under test while it achieves to reveal more faults than standard structural testing criteria. Despite its potential, mutation fails to be adopted in a widespread practical use and its popularity falls significantly short when compared with other structural methods. This can be attributed to the lack of thorough studies dealing with the practical problems introduced by mutation and the assessment of the effort needed when applying it. Such an incident, masks the real cost involved preventing the development of easy and effective to use strategies to circumvent this problem. Objective: In this paper, a path selection strategy for selecting test cases able to effectively kill mutants when performing weak mutation testing is presented and analysed. Method: The testing effort is highly correlated with the number of attempts the tester makes in order to generate adequate test cases. Therefore, a significant influence on the efficiency associated with a test case generation strategy greatly depends on the number of candidate paths selected in order to achieve a predefined coverage goal. The effort can thus be related to the number of infeasible paths encountered during the test case generation process. Results: An experiment, investigating well over 55 million of program paths is conducted based on a strategy that alleviates the effects of infeasible paths. Strategy details, along with a prototype implementation are reported and analysed through the experimental results obtained by its employment to a set of program units. Conclusion: The results obtained suggest that the strategy used can play an important role in making the mutation testing method more appealing and practical. ",
      "keywords": "Software testing,Unit testing,Mutation testing,Path testing,Adequacy criterion,Infeasible paths",
      "references": [
        3,
        9,
        13,
        17,
        18,
        20,
        30,
        34,
        42,
        48,
        49,
        60,
        63
      ]
    },
    {
      "id": 70,
      "title": "MESSI: Mutant Evaluation by Static Semantic Interpretation",
      "abstract": " Mutation testing is effective at measuring the adequacy of a test suite, but it can be computationally expensive to apply all the test cases to each mutant. Previous research has investigated the effect of reducing the number of mutants by selecting certain operators, sampling mutants at random, or combining them to form new higher-order mutants. In this paper, we propose a new approach to the mutant reduction problem using static analysis. Symbolic representations are generated for the output along the paths through each mutant and these are compared with the original program. By calculating the range of their output expressions, it is possible to determine the effect of each mutation on the program output. Mutants with little effect on the output are harder to kill. We confirm this using random testing and an established test suite. Competent programmers are likely to only make small mistakes in their programming code. We argue therefore that test suites should be evaluated against those mutants that are harder to kill without being equivalent to the original program.",
      "keywords": "mutation testing; sampling; static analysis;",
      "references": [
        12,
        15,
        18,
        20,
        24,
        28,
        30
      ]
    },
    {
      "id": 71,
      "title": "On Generating Mutants for AspectJ Programs",
      "abstract": " Context: Mutation analysis has been widely used in research studies to evaluate the effectiveness of test suites and testing techniques. Faulty versions (i.e., mutants) of a program are generated such that each mutant contains one seeded fault. The mutation score provides a measure of effectiveness. Objective: We study three problems with the use of mutation analysis for testing AspectJ programs:The manual identification and removal of equivalent mutants is difficult and time consuming. We calculate the percentage of equivalent mutants generated for benchmark AspectJ programs using available mutation tools.The generated mutants need to cover the various fault types described in the literature on fault models for AspectJ programs. We measure the distribution of the mutants generated using available mutation tools with respect to the AspectJ fault types.We measure the difficulty of killing the generated mutants. We propose the use of simple analysis of the subject programs to prevent the generation of some equivalent mutants. Method: We revised existing AspectJ fault models and presented a fault model that removes the problems in existing fault models, such as overlapping between fault types and missing fault types. We also defined three new fault types that occur due to incorrect data-flow interactions occurring in AspectJ programs. We used three mutation tools: AjMutator, Proteum/AJ, and MuJava on three AspectJ programs. To measure the difficulty of killing the mutants created using a mutation operator, we compared the average number of the mutants killed by 10 test suites that satisfy block coverage criterion. Results: A high percentage of the mutants are equivalent. The mutation tools do not cover all the fault types. Only 4 out of 27 operators generated mutants that were easy to kill. Conclusions: Our analysis approach removed about 80% of the equivalent mutants. Higher order mutation is needed to cover all the fault types.",
      "keywords": "AspectJ,Aspect-oriented programming,Mutation testing,Fault models,Test generation,High order mutation",
      "references": [
        12,
        15,
        18,
        20,
        22,
        24,
        28,
        30,
        38
      ]
    },
    {
      "id": 72,
      "title": "Regression Mutation Testing",
      "abstract": " Mutation testing is one of the most powerful approaches for evaluating quality of test suites. However, mutation testing is also one of the most expensive testing approaches. This paper presents Regression Mutation Testing (ReMT), a new technique to speed up mutation testing for evolving systems. The key novelty of ReMT is to incrementally calculate mutation testing results for the new program version based on the results from the old program version; ReMT uses a static analysis to check which results can be safely reused. ReMT also employs a mutation-specific test prioritization to further speed up mutation testing. We present an empirical study on six evolving systems, whose sizes range from 3.9KLoC to 88.8KLoC. The empirical results show that ReMT can substantially reduce mutation testing costs, indicating a promising future for applying mutation testing on evolving software systems. ",
      "keywords": "  Regression Mutation Testing, Mutation Testing, Regression Testing, Software Evolution, Static Analysis",
      "references": [
        3,
        4,
        5,
        12,
        15,
        17,
        20,
        24,
        30,
        38,
        43,
        52,
        53,
        63
      ]
    },
    {
      "id": 73,
      "title": "Incremental Refinement Checking for Test Case Generation",
      "abstract": " We combine model-based testing and mutation testing to automatically generate a test suite that achieves a high mutation adequacy score. The original model representing the system under test is mutated. To generate test cases that detect whether a modelled fault has been implemented, we perform a refinement check between the original and the mutated models. Action systems serve as formal models. They are well-suited to model reactive systems and allow non-determinism. We extend our previous work by two techniques to improve efficiency: (1) a strategy to efficiently handle a large number of mutants and (2) incremental solving. A case study illustrates the potential of our improvements. The runtime for checking appr. 200 mutants could be reduced from 20s to 3s. We implemented our algorithms in two versions: one uses a constraint solver, the other one an SMT solver. Both show similar performance. ",
      "keywords": " ",
      "references": []
    },
    {
      "id": 74,
      "title": "Reduction of Computational Cost in Mutation Testing by Sampling Mutants",
      "abstract": " The objective of this chapter is to explore the reduction of computational costs of mutation testing by randomly sampling mutants. Several experiments were conducted in the Eclipse environment using MuClipse and CodePro plugins and especially designed and implemented tools: Mutants Remover and Console Output Analyser. Six types of mutant' subsets were generated and examined. Mutation score and the source code coverage were used to evaluate the effectiveness of mutation testing with subsets of mutants. The ability to detect errors introduced \"on purpose\" in the source code was also examined. ",
      "keywords": "",
      "references": [
        12,
        15,
        17,
        18,
        20,
        21,
        70
      ]
    },
    {
      "id": 75,
      "title": "Towards Incremental Mutation Testing",
      "abstract": " Proponents of Agile development processes claim that adhering to Agile principles leads to the delivery of high quality code in evolutionary increments. Confidence in resulting systems is mostly gained through the use of unit test suites, entrusted to catch regressions as soon as they occur. Consequently, the system can only be as trustworthy as its tests, meaning that measurements of the testsE quality is crucial. Whilst mutation testing has been proposed as a means of uncovering test suite defects, it has not been widely adopted in the industry; mainly due to its computational expense and manual effort required by developers investigating unkilled mutants. To make mutation testing affordable, we propose incremental mutation testing - a variation of mutation testing which leverages the iterative nature of agile development by limiting the scope of mutant generation to sections of code which have changed since the last mutation run. Preliminary results show that the number of mutants generated is drastically reduced along with the time required to generate mutants and execute tests against them. ",
      "keywords": "  Mutation Testing, Agile Development Processes, Incremental Mutation Testing",
      "references": []
    },
    {
      "id": 76,
      "title": "Empirical Evaluation of the Statement Deletion Mutation Operator",
      "abstract": " Mutation analysis is widely considered to be an exceptionally effective criterion for designing tests. It is also widely considered to be expensive in terms of the number of test requirements and in the amount of execution needed to create a good test suite. This paper posits that simply deleting statements, implemented with the statement deletion (SDL) mutation operators in Mothra, is enough to get very good tests. A version of the SDL operator for Java was designed and implemented inside the muJava mutation system. The SDL operator was applied to 40 separate Java classes, tests were designed to kill the non-equivalent SDL mutants, and then run against all mutants. ",
      "keywords": "",
      "references": [
        3,
        5,
        6,
        12,
        13,
        14,
        15,
        17,
        20,
        30,
        38,
        44,
        81
      ]
    },
    {
      "id": 77,
      "title": "A Quality Estimation of Mutation Clustering in C# Programs",
      "abstract": " Mutation testing tasks are expensive in time and resources. Different cost reduction methods were developed to cope with this problem. In this chapter experimental evaluation of mutation clustering is presented. The approach was applied for object-oriented and standard mutation testing of C# programs. The quality metric was used to compare different solutions. It calculates a tradeoff between mutations score accuracy and mutation costs in terms of number of mutants and number of tests. The results show a substantive decrease in number of mutants and tests while suffering a small decline of mutation score accuracy. However the outcome is not superior to other cost reduction methods, as selective mutation or mutant sampling.",
      "keywords": "",
      "references": [
        8,
        15,
        40,
        52,
        55,
        58,
        61,
        72
      ]
    },
    {
      "id": 78,
      "title": "Towards the Practical Mutation Testing of AspectJ Programs",
      "abstract": " Mutation testing is a test selection criterion that relies on the assumption that test cases which can reveal artificial faults in the software are also good to reveal the real ones. It helps to expose faults which would go otherwise unnoticed. This criterion has been shown to be a promising means to deal with testing-related specificities of contemporary programming techniques such as Aspect-Oriented Programming. However, to date the few initiatives for customising mutation testing for aspect-oriented (AO) programs show either limited coverage with respect to the range of simulated faults, or a need for both adequate tool support and proper evaluation in regard to properties like application cost and effectiveness. This article tackles these limitations by describing a comprehensive mutation-based testing approach for programs written in AspectJ, which represents the most investigated AO programming language to date. The approach encompasses the definition of a set of mutation operators for AspectJ-specific constructs and the implementation of a tool that automates the approach. The results of a preliminary evaluation study show that the mutation operators are able to simulate faults that may not be revealed by pre-existing, non-mutation-based test suites. The results also suggest that the approach seems not to overwhelm the testers and hence represents a step towards the practical fault-based testing of AspectJ-like programs. ",
      "keywords": "  Mutation testing,Aspect-oriented programming\nAspectJ,Testing AspectJ programs,Test evaluation",
      "references": [
        8,
        17,
        18,
        24,
        37
      ]
    },
    {
      "id": 79,
      "title": "Selective Mutation Testing for Concurrent Code",
      "abstract": " Concurrent code is becoming increasingly important with the advent of multi-cores, but testing concurrent code is challenging. Researchers are developing new testing techniques and test suites for concurrent code, but evaluating these techniques and test suites often uses a small number of real or manually seeded bugs. Mutation testing allows creating a large number of buggy programs to evaluate test suites. However, performing mutation testing is expensive even for sequential code, and the cost is higher for concurrent code where each test has to be executed for many (possibly all) thread schedules. The most widely used technique to speed up mutation testing is selective mutation, which reduces the number of mutants by applying only a subset of mutation operators such that test suites that kill all mutants generated by this subset also kill (almost) all mutants generated by all mutation operators. To date, selective mutation has been used only for sequential mutation operators. This paper explores selective mutation for concurrent mutation operators. Our results identify several sets of concurrent mutation operators that can effectively reduce the number of mutants, show that operator-based selection is slightly better than random mutant selection, and show that sequential and concurrent mutation operators are independent, demonstrating the importance of studying concurrent mutation operators.",
      "keywords": "  Selective mutation testing, concurrent code",
      "references": [
        8,
        9,
        17,
        24,
        33,
        38,
        43,
        46,
        52,
        72,
        89
      ]
    },
    {
      "id": 80,
      "title": "Using Fault History to Improve Mutation Reduction",
      "abstract": " Mutation testing can be used to measure test suite quality in two ways: by treating the kill score as a quality metric, or by treating each surviving, non-equivalent mutant as an indicator of an inadequacy in the test suite. The first technique relies on the assumption that the mutation score is highly correlated with the suite's real fault detection rate, which is not well supported by the literature. The second technique relies only on the weaker assumption that the \"interesting\" mutants (i.e., the ones that indicate an inadequacy in the suite) are in the set of surviving mutants. Using the second technique also makes improving the suite straightforward. Unfortunately, mutation testing has a performance problem. At least part of the test suite must be run on every mutant, meaning mutation testing can be too slow for practical use. Previous work has addressed this by reducing the number of mutants to evaluate in various ways, including selecting a random subset of them. However, reducing the set of mutants by random reduction is suboptimal for developers using the second technique described above, since random reduction will eliminate many of the interesting mutants. We propose a new reduction method that supports the use of the second technique by reducing the set of mutants to those generated by altering files that have contained many faults in the past. We performed a pilot study that suggests that this reduction method preferentially chooses mutants that will survive mutation testing; that is, it preserves a greater number of interesting mutants than random reduction does.",
      "keywords": "  Mutation testing, mutant reduction, fault history, test suite\nquality",
      "references": [
        3,
        5,
        9,
        15,
        17,
        24,
        38,
        52,
        72
      ]
    },
    {
      "id": 81,
      "title": "Improving logic-based testing",
      "abstract": " Logic-based testers design tests from logical expressions that appear in software artifacts such as source code, design models, and requirements specifications. This paper presents three improvements to logic-based test design. First, in the context of mutation testing, we present fault hierarchies for the six relational operators. Applying the ROR mutation operator causes each relational operator to generate seven mutants per clause. The fault hierarchies show that only three of these seven mutants are needed. Second, we show how to bring the power of the ROR operator to logic-based test criteria such as the widely used Multiple Condition-Decision Coverage (MCDC) test criterion. Third, we present theoretical results supported by empirical data that show that the more recent coverage criterion of minimal-MUMCUT can find significantly more faults than MCDC. The paper has three specific recommendations: (1) Change the way the ROR mutation operator is defined in existing and future mutation systems. (2) Augment logic-based test criteria to incorporate relational operator replacement from mutation. (3) Replace the use of MCDC with minimal-MUMCUT, both in practice and in standards documents like FAA-DO178B. ",
      "keywords": "Software testing,Logic-based testing,\nMutation analysis,MCDC",
      "references": [
        13,
        17,
        30,
        41,
        53,
        57,
        63
      ]
    },
    {
      "id": 82,
      "title": "Identifying More Equivalent Mutants via Code Similarity",
      "abstract": " Equivalent mutants are one of the major costs of mutation testing. The undecidable nature of this problem makes a fully automated solution unattainable and necessitates the manual analysis of live mutants. This paper introduces the concept of mirrored mutants; ones that affect similar code fragments. It is argued that mirrored mutants exhibit analogous behavior with respect to their equivalence. Thus, if one of them is equivalent, then the other mirrored mutants should be too. An empirical study, conducted on real world programs, investigates this argument, focusing on both intra-method and inter-method mirrored mutants. The obtained results suggest that mirrored mutants indeed exhibit this kind of behavior and thus can be utilized to ameliorate the adverse effects of the equivalent mutant problem. ",
      "keywords": " mutation testing; equivalent mutants; similar code fragments",
      "references": [
        12,
        17,
        18,
        20,
        30,
        45,
        47,
        48,
        49,
        87
      ]
    },
    {
      "id": 83,
      "title": "Parallel Mutation Testing",
      "abstract": " Despite the existing techniques to reduce the costs of mutation analysis, the computational cost to apply mutation testing with large applications can be very high. One effective technique to improve the efficiency of mutation without losing effectiveness is parallel execution, where mutants and tests are executed in parallel processors, reducing the total time needed to perform mutation analysis. This paper presents a study of this technique adapted to current technologies. Five algorithms to execute mutants in parallel are analysed with three studies that use different network configurations and different number of processors with diverse characteristics. The experiments are performed with Bacterio P, a tool that is also presented. Unlike previous studies about parallel mutant execution, which date from the mid-1990s, in the studies in this paper, the communication time in parallel systems no longer acts as a bottleneck. Thus, dynamic strategies, which require more communication, combined with other mutant cost reduction techniques, are the best strategies to run mutants in parallel.",
      "keywords": "mutation testing; parallel execution",
      "references": [
        4,
        5,
        6,
        10,
        11,
        13,
        14,
        17,
        24,
        30
      ]
    },
    {
      "id": 84,
      "title": "software testing; mutation testing",
      "abstract": " Mutation has been recognized to be an effective software testing technique. It is based on the insertion of artificial faults in the system under test (SUT) by means of a set of mutation operators. Different operators can mutate each program statement in several ways, which may produce a huge number of mutants. This leads to very high costs for test case execution and result analysis. Several works have approached techniques for cost reduction in mutation testing, like (n)-order mutation where each mutant contains (n) artificial faults instead of one. There are two approaches to (n)-order mutation: increasing the effectiveness of mutation by searching for good (n)-order mutants, and decreasing the costs of mutation testing by reducing the mutants set through the combination of the first-order mutants into (n)-order mutants. This paper is focused on the second approach. However, this second use entails a risk: the possibility of leaving undiscovered faults in the SUT, which may distort the perception of the test suite quality. This paper describes an empirical study of different combination strategies to compose second-order mutants at system level as well as a cost-risk analysis of (n)-order mutation at system level. ",
      "keywords": "Empirical evaluation, high-order mutation, mutation testing",
      "references": [
        12,
        17,
        18,
        20,
        21,
        24,
        30,
        45,
        47,
        48,
        56,
        58
      ]
    },
    {
      "id": 85,
      "title": "A Coevolutionary Algorithm to Automatic Test Case Selection and Mutant in Mutation Testing",
      "abstract": " One of the main problems to perform the Software Testing is to find a set of tests (subset from input domain of the problem) which is effective to detect the remaining bugs in the software. The Search-Based Software Testing (SBST) approach uses metaheuristics to find low cost set of tests with a high effectiveness to detect bugs. From several existing test criteria, Mutation Testing is considered quite promising to reveal bugs, despite its high computational cost, due to the great quantity of mutant programs generated. Therefore, this paper addresses the problem of selecting mutant programs and test cases in Mutation Testing context. To this end, it is proposed a Coevolutionary Genetic Algorithm (CGA) and the concept of Genetic Effectiveness, describing a new representation and implementing new genetic operators. The CGA is applied in five benchmarks and the results are compared to other five methods, showing a better performance of the proposed algorithm in subsets automatic selection with better mutation score and greater reduction of computational cost, specifically the amount of testing, when compared with exhaustive test. ",
      "keywords": "Mutation Testing; Search-Based Software Testing;\nGenetic Algorithm; Coevolution",
      "references": [
        28,
        45
      ]
    },
    {
      "id": 86,
      "title": "Mutation Testing Strategies using Mutant Classification",
      "abstract": " Mutation testing has a widespread reputation of being a rather powerful testing technique. However, its practical application requires the detection of equivalent mutants. Detecting equivalent mutants is cumbersome since it requires manual analysis, resulting in unbearable testing cost. To overcome this difficulty, researchers have proposed the use of mutant classification, an approach that helps isolating equivalent mutants. From this perspective, the present paper establishes and assesses possible mutant classification strategies. The conducted study suggests that while mutant classification can be useful in isolating equivalent mutants, it fails to kill some mutants. Indeed, the experimental results show that the proposed strategies achieve to kill approximately 95% of the introduced killable mutants.",
      "keywords": "Mutation Testing, Mutants\u2019 Impact, Mutant Classification.",
      "references": [
        18,
        20,
        28,
        38,
        43,
        47,
        48,
        49,
        60,
        87
      ]
    },
    {
      "id": 87,
      "title": "Covering and Uncovering Equivalent Mutants",
      "abstract": " Mutation testing measures the adequacy of a test suite by seeding artificial defects (mutations) into a program. If a test suite fails to detect a mutation, it may also fail to detect real defects - and hence should be improved. However, there are also mutations that keep the program semantics unchanged and thus cannot be detected by any test suite. Such equivalent mutants must be weeded out manually, which is a tedious task. In this paper, we examine whether changes in coverage can be used to detect non-equivalent mutants: If a mutant changes the coverage of a run, it is more likely to be non-equivalent. In a sample of 140 manually classified mutations of seven Java programs with 5000 to 100 000 lines of code, we found that (i) the problem is serious and widespread - about 45% of all undetected mutants turned out to be equivalent; (ii) manual classification takes time - about 15 min per mutation; (iii) coverage is a simple, efficient and effective means to identify equivalent mutants - with a classification precision of 75% and a recall of 56%; and (iv) coverage as an equivalence detector is superior to the state of the art, in particular violations of dynamic invariants. Our detectors have been released as part of the open-source JAVALANCHE framework; the data set is publicly available for replication and extension of experiments.",
      "keywords": "mutation testing; code coverage; dynamic analysis",
      "references": [
        9,
        12,
        17,
        18,
        20,
        28,
        43
      ]
    },
    {
      "id": 88,
      "title": "Efficient Mutation Analysis of Relational Database Structure Using Mutant Schemata and Parallelisation",
      "abstract": " Mutation analysis is an effective way to assess the quality of input values and test oracles. Yet, since this technique requires the generation and execution of many mutants, it often incurs a substantial computational cost. In the context of program mutation, the use of mutant schemata and parallelisation can reduce the costs of mutation analysis. This paper is the first to apply these approaches to the mutation analysis of a relational database schema, arguably one of the most important artefacts in a database application. Using a representative set of case studies that vary in both their purpose and structure, this paper empirically compares an unoptimised method to four database structure mutation techniques that intelligently employ both mutant schemata and parallelisation. The results of the experimental study highlight the performance trade-offs that depend on the type of database management system (DBMS), underscoring the fact that every DBMS does not support all types of efficient mutation analysis. However, the experiments also identify a method that yields a one to ten times reduction in the cost of mutation analysis for relational schemas hosted by both the Postgres and SQLite DBMSs. ",
      "keywords": "",
      "references": [
        5,
        9,
        30,
        36,
        83
      ]
    },
    {
      "id": 89,
      "title": "Faster Mutation Testing Inspired by Test Prioritization and Reduction",
      "abstract": " Mutation testing is a well-known but costly approach for determining test adequacy. The central idea behind the approach is to generate mutants, which are small syntactic transformations of the program under test, and then to measure for a given test suite how many mutants it kills. A test t is said to kill a mutant m of program p if the output of t on m is different from the output of t on p. The effectiveness of mutation testing in determining the quality of a test suite relies on the ability to apply it using a large number of mutants. However, running many tests against many mutants is time consuming. We present a family of techniques to reduce the cost of mutation testing by prioritizing and reducing tests to more quickly determine the sets of killed and non-killed mutants. Experimental results show the effectiveness and efficiency of our techniques.",
      "keywords": "Mutation testing, Test Prioritization, Test Reduction",
      "references": [
        3,
        15,
        17,
        24,
        38,
        43,
        52,
        65,
        72,
        79
      ]
    },
    {
      "id": 90,
      "title": "Operator-Based and Random Mutant Selection: Better Together",
      "abstract": " Mutation testing is a powerful methodology for evaluating the quality of a test suite. However, the methodology is also very costly, as the test suite may have to be executed for each mutant. Selective mutation testing is a well-studied technique to reduce this cost by selecting a subset of all mutants, which would otherwise have to be considered in their entirety. Two common approaches are operator-based mutant selection, which only generates mutants using a subset of mutation operators, and random mutant selection, which selects a subset of mutants generated using all mutation operators. While each of the two approaches provides some reduction in the number of mutants to execute, applying either of the two to medium-sized, real-world programs can still generate a huge number of mutants, which makes their execution too expensive. This paper presents eight random sampling strategies defined on top of operator-based mutant selection, and empirically validates that operator-based selection and random selection can be applied in tandem to further reduce the cost of mutation testing. The experimental results show that even sampling only 5% of mutants generated by operator-based selection can still provide precise mutation testing results, while reducing the average mutation testing time to 6.54% (i.e., on average less than 5 minutes for this study). ",
      "keywords": "",
      "references": [
        3,
        4,
        5,
        8,
        9,
        13,
        15,
        17,
        24,
        38,
        43,
        52,
        53,
        63,
        72,
        79,
        89
      ]
    },
    {
      "id": 91,
      "title": "Model-Based Mutation Testing of an Industrial Measurement Device",
      "abstract": " MoMuT::UML is a model-based mutation testing tool for UML models. It maps UML state machines to a formal semantics and performs a conformance check between an original and a set of mutated models to automatically generate test cases. The resulting test suite is able to detect whether a system under test implements one of the faulty models instead of the correct, original model. In this work, we illustrate the whole model-based mutation testing process by means of an industrial case study. We test the control logic of a device that counts the particles in exhaust gases. First, we model the system under test in UML. Then, MoMuT::UML is used to automatically generate three test suites from the UML test model: one mutation-based test suite, one set of random test cases, and a third test suite combining random and mutation-based test case generation. The test cases are executed on the system under test and effectively reveal several errors. Finally, we compare the fault detection capabilities of the three test suites on a set of faulty systems, which were created by intentionally injecting faults into the implementation. ",
      "keywords": "test case generation, model-based testing, mutation testing, automotive industry, UML",
      "references": [
        73
      ]
    },
    {
      "id": 92,
      "title": "Establishing Theoretical Minimal Sets of Mutants",
      "abstract": " Mutation analysis generates tests that distinguish variations, or mutants, of an artifact from the original. Mutation analysis is widely considered to be a powerful approach to testing, and hence is often used to evaluate other test criteria in terms of mutation score, which is the fraction of mutants that are killed by a test set. But mutation analysis is also known to provide large numbers of redundant mutants, and these mutants can inflate the mutation score. While mutation approaches broadly characterized as reduced mutation try to eliminate redundant mutants, the literature lacks a theoretical result that articulates just how many mutants are needed in any given situation. Hence, there is, at present, no way to characterize the contribution of, for example, a particular approach to reduced mutation with respect to any theoretical minimal set of mutants. This paper's contribution is to provide such a theoretical foundation for mutant set minimization. The central theoretical result of the paper shows how to minimize efficiently mutant sets with respect to a set of test cases. We evaluate our method with a widely-used benchmark. ",
      "keywords": "Mutation testing, minimal mutant sets, dynamic subsumption",
      "references": [
        8,
        14,
        15,
        17,
        21,
        24,
        41,
        44,
        48,
        76,
        81,
        95
      ]
    },
    {
      "id": 93,
      "title": "Reductions of Operators in Java Mutation Testing",
      "abstract": " The objective of this chapter is to explore the reduction of computational costs of mutation testing of Java programs by selective mutations \u2013 omitting mutants generated for a mutation operator. The approaches to reduce the effort in mutation testing are briefly described. The idea of choosing a mutations operator and omitting mutants generated by it is described, next several experiments, conducted in the Eclipse environment using MuClipse and CodePro plugins, are presented in details. Two especially designed and implemented tools: Mutants Remover and Console Output Analyser were also used in experiments. Mutation score was used to evaluate the effectiveness of selective mutation testing. ",
      "keywords": "mutation testing, cost reduction, Java testing.",
      "references": [
        12,
        15,
        17,
        18,
        20,
        21,
        45,
        61,
        70,
        74,
        77,
        83
      ]
    },
    {
      "id": 94,
      "title": "Reduction in Mutation Testing of Java Classes",
      "abstract": " In mutation analysis many simple modification of the original program called \"mutants\" are created. Test cases which are supposed to identify the introduced program changes are designed. Each mutant must be \"killed\" by a test case, i.e. the test case should detect the purposely introduced modification. Mutation testing is known to be effective but computationally demanding and time consuming because a large number of mutants has to be tested. Mutation score, which is the fraction of mutants that are killed by a test set, is often used to evaluate the effectiveness of mutation testing. An interesting research question is if the number of mutants can be reduced without significantly decreasing the effectiveness of the test. We were exploring selective reductions of mutants generated for Java programs. The results of several experiments conducted in the Eclipse environment are presented in this paper. These results show that selective reduction in mutants can significantly reduce the cost of testing with acceptable mutation score and code coverage.",
      "keywords": "Mutation Testing, Cost Reduction, Java Testing",
      "references": [
        12,
        15,
        17,
        18,
        20,
        21,
        58,
        61,
        70,
        74,
        77,
        83,
        92,
        96,
        103
      ]
    },
    {
      "id": 95,
      "title": "Experimental Evaluation of SDL and One-Op Mutation for C",
      "abstract": "Mutation analysis modifies a program by applying syntactic rules, called mutation operators, systematically to create many versions of the program (mutants) that differ in small ways. Testers then design tests to cause the mutants to behave differently from the original program. Mutation testing is widely considered to result in very effective tests, however, it is also quite costly. Cost comes from the many mutants that are created, the number of tests that are needed to kill the mutants, and the difficulty of deciding whether mutants behave equivalently to the original program. One-op mutation theorizes that cost can be reduced by using a single, very powerful, mutation operator that leads to tests that are almost as effective as if all operators are used. Previous research proposed the statement deletion operator (SDL) and found promising results. This paper investigates the use of SDL-mutation in a new context, the language C, and poses additional empirical questions, including whether other operators can be used. We carried out a controlled experiment in which cost and effectiveness of each individual C mutation operator were collected for 39 different subject programs. Experimental data are used to define a cost-effectiveness metric to choose the best single operator for one-op mutation.",
      "keywords": "",
      "references": []
    },
    {
      "id": 96,
      "title": "Designing Deletion Mutation Operators",
      "abstract": "As a test criterion, mutation analysis is known for yielding very effective tests. It is also known for creating many test requirements, each of which is represented by a 'mutant' that must be 'killed.' In recent years, researchers have found that these test requirements have a lot of duplication, in that many test requirements yield the same tests. Put another way, hundreds of mutants can usually be killed by only a few dozen tests. If we could reduce this duplication without reducing mutation's effectiveness, mutation testing could become more cost-effective. One avenue of this research has been to use only one type of mutant, the statement deletion mutation operator. Researchers have found that statement deletion mutation has relatively few mutants, but yields tests that are almost as effective as using all mutants, with the significant benefit that fewer equivalent mutants are generated. This paper extends this idea by asking a simple question: if deleting statements is a cost-effective way to design tests, will deleting other program elements also be effective? This paper presents results from mutation operators that delete variables, operators, and constants, finding that indeed, this is an efficient and effective approach. ",
      "keywords": "Software testing; Mutation testing; Mutation operators; SDL-mutation; One-op mutation",
      "references": [
        14,
        15,
        17,
        24,
        30,
        44,
        76
      ]
    },
    {
      "id": 97,
      "title": "Growing a Reduced Set of Mutation Operators",
      "abstract": "Although widely considered to be quite powerful, mutation testing is also known for its expense. Three fundamental (and related) sources for much of the expense are (1) the number of mutants, (2) the number of equivalent mutants, and (3) the number of test cases needed to kill the mutants. Recent results have shown that mutation systems create a significant number of mutants that are killed by the same tests. These mutants can be considered to be 'redundant,' in the sense that if N mutants are killed by the same test, only one of those mutants is truly needed. Selective mutation, one-op mutation, and random mutant selection are ways to choose a 'reduced' set of mutation operators that will help testers design tests that are almost as effective, as measured by running the tests against the complete set of mutants. This paper presents a novel procedure for choosing a reduced set of mutation operators based on a 'growth model.' The procedure uses a greedy approach to successively choose the mutation operator that increases the overall mutation score the most, adding mutation operators to the set until the tests that kill all mutants from the reduced set kill all mutants from the complete set of mutants. ",
      "keywords": "",
      "references": [
        14,
        15,
        17,
        24,
        30,
        32,
        38,
        44,
        76,
        84,
        92,
        95
      ]
    },
    {
      "id": 98,
      "title": "Angels and Monsters: An Empirical Investigation of Potential Test Effectiveness and Efficiency Improvement from Strongly Subsuming Higher Order Mutation",
      "abstract": "We study the simultaneous test effectiveness and efficiency improvement achievable by Strongly Subsuming Higher Order Mutants (SSHOMs), constructed from 15,792 first order mutants in four Java programs. Using SSHOMs in place of the first order mutants they subsume yielded a 35%-45% reduction in the number of mutants required, while simultaneously improving test efficiency by 15% and effectiveness by between 5.6% and 12%. Trivial first order faults often combine to form exceptionally non-trivial higher order faults; apparently innocuous angels can combine to breed monsters. Nevertheless, these same monsters can be recruited to improve automated test effectiveness and efficiency. \u00a9 2014 ACM.",
      "keywords": "Software testing; Mutation testing; Mutation operator; Mutation operator selection",
      "references": [
        8,
        9,
        36,
        38,
        45,
        48,
        63,
        72,
        100
      ]
    },
    {
      "id": 99,
      "title": "Mutation-Based Generation of Software Product Line Test Configurations",
      "abstract": "Software Product Lines (SPLs) are families of software products that can be configured and managed through a combination of features. Such products are usually represented with a Feature Model (FM). Testing the entire SPL may not be conceivable due to economical or time constraints and, more simply, because of the large number of potential products. Thus, defining methods for generating test configurations is required, and is now a very active research topic for the testing community. In this context, mutation has recently being advertised as a promising technique. Mutation evaluates the ability of the test suite to detect defective versions of the FM, called mutants. In particular, it has been shown that existing test configurations achieving the mutation criterion correlate with fault detection. Despite the potential benefit of mutation, there is no approach which aims at generating test configurations for SPL with respect to the mutation criterion. In this direction, we introduce a search-based approach which explores the SPL product space to generate product test configurations with the aim of detecting mutants.",
      "keywords": " Software Product Lines, Test Configuration Generation, Search-Based Software Engineering, Mutation, Feature Models",
      "references": [
        58,
        63,
        69,
        81
      ]
    },
    {
      "id": 100,
      "title": "Efficient Mutation Analysis by Propagating and Partitioning Infected Execution States",
      "abstract": "Mutation analysis evaluates a testing technique by measuring how well it detects seeded faults (mutants). Mutation analysis is hampered by inherent scalability problems | a test suite is executed for each of a large number of mutants. Despite numerous optimizations presented in the literature, this scalability issue remains, and this is one of the reasons why mutation analysis is hardly used in practice. Whereas most previous optimizations attempted to statically reduce the number of executions or their computational overhead, this paper exploits information available only at run time to further reduce the number of executions. First, state infection conditions can reveal | with a single test execution of the unmutated program | which mutants would lead to a different state, thus avoiding unnecessary test executions. Second, determining whether an infected execution state propagates can further reduce the number of executions. Mutants that are embedded in compound expressions may infect the state locally without affecting the outcome of the compound expression. Third, those mutants that do infect the state can be partitioned based on the resulting infected state | if two mutants lead to the same infected state, only one needs to be executed as the result of the other can be inferred. We have implemented these optimizations in the Major mutation framework and empirically evaluated them on 14 open source programs. The optimizations reduced the mutation analysis time by 40% on average. ",
      "keywords": "Mutation analysis, software testing, dynamic analysis",
      "references": [
        8,
        9,
        11,
        12,
        20,
        28,
        38,
        43,
        49,
        53,
        56,
        63,
        65,
        89,
        111
      ]
    },
    {
      "id": 101,
      "title": "Using Data Flow Patterns for Equivalent Mutant Detection",
      "abstract": "This paper introduces a set of data flow patterns that reveal code locations able to produce equivalent mutants. For each pattern, a formal definition is given and the necessary conditions implying its existence in the source code of the program under test are described. By identifying such problematic situations, the introduced patterns can provide advice on code locations that should not be mutated. Apart from dealing with equivalent mutants, the proposed patterns are able to identify specific paths for which a mutant is functionally equivalent to the original program. This knowledge can be leveraged by test case generation techniques in order not to target these paths when attempting to kill the corresponding mutants. An empirical study, conducted on a set of manually identified equivalent mutants, provides evidence regarding the detection power of the introduced patterns and unveils their existence in real world software.",
      "keywords": "data flow analysis; mutation testing; equivalent mutants",
      "references": [
        12,
        17,
        18,
        20,
        22,
        30,
        49,
        63,
        82,
        87
      ]
    },
    {
      "id": 102,
      "title": "Towards the Establishment of a Sufficient Set of Mutation Operators for AspectJ Programs",
      "abstract": " Mutation testing is an effective test selection criterion that has been explored in the context of aspect-oriented (AO) programs written in the AspectJ language. Despite its effectiveness, mutation testing is expensive. To reduce its application cost, some strategies based on mutation operator selection are available in the literature. This paper describes the results of a study that aimed to reduce the costs of applying mutation testing to AspectJ programs by identifying a reduced set of mutation operators known as sufficient operators. To achieve the proposed objective, we applied the Sufficient Procedure, which has resulted in expressive cost reductions when applied to procedural programs. Indeed, the procedure led to a small set of operators and to a cost reduction of 53% in terms of number of mutants to be handled.",
      "keywords": "",
      "references": [
        8,
        24,
        68,
        71,
        78
      ]
    },
    {
      "id": 103,
      "title": "Overcoming the Equivalent Mutant Problem: A Systematic Literature Review and a Comparative Experiment of Second Order Mutation",
      "abstract": "The equivalent mutant problem (EMP) is one of the crucial problems in mutation testing widely studied over decades. Objectives. The objectives are: to present a systematic literature review (SLR) in the field of EMP; to identify, classify and improve the existing, or implement new, methods which try to overcome EMP and evaluate them. Method. We performed SLR based on the search of digital libraries. We implemented four second order mutation (SOM) strategies, in addition to first order mutation (FOM), and compared them from different perspectives. Results. Our SLR identified 17 relevant techniques (in 22 articles) and three categories of techniques: detecting (DEM); suggesting (SEM); and avoiding equivalent mutant generation (AEMG). The experiment indicated that SOM in general and JudyDiffOp strategy in particular provide the best results in the following areas: total number of mutants generated; the association between the type of mutation strategy and whether the generated mutants were equivalent or not; the number of not killed mutants; mutation testing time; time needed for manual classification. Conclusions. The results in the DEM category are still far from perfect. Thus, the SEM and AEMG categories have been developed. The JudyDiffOp algorithm achieved good results in many areas. ",
      "keywords": "Mutation testing, equivalent mutant problem, higher order mutation, second order mutation",
      "references": [
        12,
        18,
        20,
        21,
        22,
        27,
        28,
        30,
        33,
        41,
        43,
        45,
        47,
        48,
        51,
        87
      ]
    },
    {
      "id": 104,
      "title": "Reducing Mutation Costs Through Uncovered Mutants",
      "abstract": "Mutation testing is a very effective testing technique that creates mutants in order to design test cases that will kill the mutants. One problem of mutation testing is high costs: creating mutants, executing mutants and calculating the mutation score. This paper empirically analyzes the effect of covering mutants through the mutant schema improved with extra code (MUSIC) technique. This technique annotates the statements covered by the tests in the original system in order to filter the mutant executions, because tests are only executed against the mutants whose mutated statement is covered by the tests. Therefore, MUSIC is meant to reduce the number of required executions and identify infinite loops at a reduced cost. Besides, an experiment was performed to evaluate the advantages and disadvantages of analyzing the covered mutants. As a result, we conclude that analyzing the covered mutants reduces the execution cost of mutation testing and its application is therefore recommended.",
      "keywords": "mutation testing; empirical analysis; MUSIC; execution cost reduction; infinite loops",
      "references": [
        4,
        5,
        9,
        13,
        21,
        30,
        49,
        56,
        60,
        63
      ]
    },
    {
      "id": 105,
      "title": "Mitigating the Effects of Equivalent Mutants with Mutant Classification Strategies",
      "abstract": "Mutation Testing has been shown to be a powerful technique in detecting software faults. Despite this advantage, in practice there is a need to deal with the equivalent mutants' problem. Automatically detecting equivalent mutants is an undecidable problem. Therefore, identifying equivalent mutants is cumbersome since it requires manual analysis, resulting in unbearable testing cost. To overcome this difficulty, researchers suggested the use of mutant classification, an approach that aims at isolating equivalent mutants automatically. From this perspective, the present paper establishes and empirically assesses possible mutant classification strategies. A conducted study reveals that mutant classification isolates equivalent mutants effectively when low quality test suites are used. However, it turns out that as the test suites evolve, the benefit of this practice is reduced. Thus, mutant classification is only fruitful in improving test suites of low quality and only up to a certain limit. To this end, empirical results show that the proposed strategies provide a cost-effective solution when they consider a small number of live mutants, i.e., 10-12. At this point they kill 92% of all the killable mutants. ",
      "keywords": "Mutation analysis Mutants\u2019 impact Equivalent mutants Mutant classification Mutation testing strategies ",
      "references": [
        18,
        20,
        28,
        38,
        43,
        47,
        48,
        49,
        60,
        69,
        86,
        87
      ]
    },
    {
      "id": 106,
      "title": "The Impact of Equivalent, Redundant and Quasi Mutants on Database Schema Mutation Analysis",
      "abstract": "Since the relational database is an important component of real-world software and the schema plays a major role in ensuring the quality of the database, relational schema testing is essential. This paper presents methods for improving both the efficiency and accuracy of mutation analysis, an established method for assessing the quality of test cases for database schemas. Using a DBMS-independent abstract representation, the presented techniques automatically identify and remove mutants that are either equivalent to the original schema, redundant with respect to other mutants, or undesirable because they are only valid for certain database systems. Applying our techniques for ineffective mutant removal to a variety of schemas, many of which are from real-world sources like the U.S. Department of Agriculture and the Stack Overflow website, reveals that the presented static analysis of the DBMS-independent representation is multiple orders of magnitude faster than a DBMS-specific method. The results also show increased mutation scores in 75% of cases, with 44% of those uncovering a mutation-adequate test suite. Combining the presented techniques yields mean efficiency improvements of up to 33.7%, with averages across schemas of 1.6% and 11.8% for HyperSQL and PostgreSQL, respectively. ",
      "keywords": "",
      "references": [
        18,
        20,
        28,
        36,
        56,
        88
      ]
    },
    {
      "id": 107,
      "title": "Exploiting Model Morphology for Event-Based Testing",
      "abstract": "Model-based testing employs models for testing. Model-based mutation testing (MBMT) additionally involves fault models, called mutants, by applying mutation operators to the original model. A problem encountered with MBMT is the elimination of equivalent mutants and multiple mutants modeling the same faults. Another problem is the need to compare a mutant to the original model for test generation. This paper proposes an event-based approach to MBMT that is not fixed on single events and a single model but rather operates on sequences of events of length k \u2265 1 and invokes a sequence of models that are derived from the original one by varying its morphology based on k. The approach employs formal grammars, related mutation operators, and algorithms to generate test cases, enabling the following: (1) the exclusion of equivalent mutants and multiple mutants; (2) the generation of a test case in linear time to kill a selected mutant without comparing it to the original model; (3) the analysis of morphologically different models enabling the systematic generation of mutants, thereby extending the set of fault models studied in related literature. Three case studies validate the approach and analyze its characteristics in comparison to random testing and another MBMT approach. ",
      "keywords": "Model-based mutation testing, grammar-based testing, (model) morphology, mutant selection, test generation",
      "references": [
        18,
        20,
        28,
        53
      ]
    },
    {
      "id": 108,
      "title": "Improving Mutation Testing Process of Python Programs",
      "abstract": "Mutation testing helps in evaluation of test suite quality and test development. It can be directed to programs of different languages. High cost of a mutation testing process limits its applicability. This paper focuses on mutation testing of Python programs, discussing several issues of mutant creation and execution. It was showed how they can be effectively handled in the Python environment. We discuss introduction of first and higher order mutation in an abstract syntax tree with use of generators, dealing with code coverage with AST, executing mutants via mutant injection into tests. The solutions were used in reengineering of MutPy - a mutation testing tool for Python programs. The improvements were positively verified in mutation experiments. ",
      "keywords": "mutation testing, Python, dynamically typed language",
      "references": [
        8,
        45,
        61,
        90,
        94
      ]
    },
    {
      "id": 109,
      "title": "A Mutation and Multi-objective Test Data Generation Approach for Feature Testing of Software Product Lines",
      "abstract": "Mutation approaches have been recently applied for feature testing of Software Product Lines (SPLs). The idea is to select products, associated to mutation operators that describe possible faults in the Feature Model (FM). In this way, the operators and mutation score can be used to evaluate and generate a test set, that is a set of SPL products to be tested. However, the generation of test sets to kill all the mutants with a reduced, possible minimum, number of products is a complex task. To solve such problem, this paper introduces a multiobjective approach that includes a representation to the problem, search operators and two objectives related to the number of test cases and dead mutants. The approach was implemented with three representative multi-objective and evolutionary algorithms: NSGA-II, SPEA2 and IBEA. The conducted evaluation analyses the solutions obtained and compares the algorithms. An advantage of this approach is to offer a set of good solutions to the tester with a reduced number of products and high mutation score values, that is, with high probability of revealing faults described by the mutation testing.",
      "keywords": "",
      "references": [
        16,
        99
      ]
    },
    {
      "id": 110,
      "title": "Achieving Scalable Mutation-based Generation of Whole Test Suites",
      "abstract": "Without complete formal specification, automatically generated software tests need to be manually checked in order to detect faults. This makes it desirable to produce the strongest possible test set while keeping the number of tests as small as possible. As commonly applied coverage criteria like branch coverage are potentially weak, mutation testing has been proposed as a stronger criterion. However, mutation based test generation is hampered because usually there are simply too many mutants, and too many of these are either trivially killed or equivalent. On such mutants, any effort spent on test generation would per definition be wasted. To overcome this problem, our search-based EvoSuite test generation tool integrates two novel optimizations: First, we avoid redundant test executions on mutants by monitoring state infection conditions, and second we use whole test suite generation to optimize test suites towards killing the highest number of mutants, rather than selecting individual mutants. These optimizations allowed us to apply EvoSuite to a random sample of 100 open source projects, consisting of a total of 8,963 classes and more than two million lines of code, leading to a total of 1,380,302 mutants. The experiment demonstrates that our approach scales well, making mutation testing a viable test criterion for automated test case generation tools, and allowing us to analyze the relationship of branch coverage and mutation testing in detail. ",
      "keywords": "Mutation testing , Test case generation , Search-based testing , Testing classes , Unit testing",
      "references": [
        8,
        11,
        12,
        13,
        16,
        18,
        20,
        28,
        34,
        49,
        53,
        63,
        65,
        76
      ]
    },
    {
      "id": 111,
      "title": "Higher Accuracy and Lower Run Time: Efficient Mutation Analysis Using Non-redundant Mutation Operators",
      "abstract": "Mutation analysis is a powerful but computationally expensive method to measure the effectiveness of a testing or debugging technique. The high cost is due, in part, to redundant mutants generated by commonly used mutation operators. A mutant is said to be redundant if its outcome can be predicted based on the outcome of other mutants. The execution of those redundant mutants is unnecessary and wastes CPU resources. Moreover, the inclusion of redundant mutants may lead to a skewed mutant detection rate and therefore misrepresent the effectiveness of the assessed testing or debugging technique. This paper extends previous work and makes the following contributions. First, it defines and provides non-redundant versions of the conditional operator replacement, unary operator insertion, and relational operator replacement mutation operators. Second, it reports on a conducted empirical study using 10 real-world programmes that comprise a total of 410-000 lines of code. The empirical study used developer-written and generated test suites. The results show how prevalent redundant mutants are and how their elimination improves the efficiency and accuracy of mutation analysis. In summary, the total mutation analysis run time decreased by more than 20% by removing redundant mutants, and the inclusion of redundant mutants led to an overestimated mutation score for all analysed test suites. ",
      "keywords": "mutation analysis; redundant mutants; test adequacy; code coverage",
      "references": [
        12,
        15,
        17,
        20,
        38,
        56,
        63,
        65,
        81,
        100
      ]
    },
    {
      "id": 112,
      "title": "Employing Second-order Mutation for Isolating First-order Equivalent Mutants",
      "abstract": "The equivalent mutant problem is a major hindrance to mutation testing. Being undecidable in general, it is only susceptible to partial solutions. In this paper, mutant classification is utilised for isolating likely to be first-order equivalent mutants. A new classification technique, Isolating Equivalent Mutants (I-EQM), is introduced and empirically investigated. The proposed approach employs a dynamic execution scheme that integrates the impact on the program execution of first-order mutants with the impact on the output of second-order mutants. An experimental study, conducted using two independently created sets of manually classified mutants selected from real-world programs revalidates previously published results and provides evidence for the effectiveness of the proposed technique. Overall, the study shows that I-EQM substantially improves previous methods by retrieving a considerably higher number of killable mutants, thus, amplifying the quality of the testing process.",
      "keywords": "mutation testing; equivalent mutants; higher-order mutation; mutants\u2019 impact; dynamic analysis",
      "references": [
        12,
        17,
        18,
        20,
        22,
        28,
        29,
        43,
        45,
        47,
        48,
        49,
        60,
        63,
        69,
        87
      ]
    },
    {
      "id": 113,
      "title": "MEDIC: A Static Analysis Framework for Equivalent Mutant Identification",
      "abstract": "Context: The equivalent mutant problem is a well-known impediment to the adoption of mutation testing in practice. In consequence of its undecidable nature, a complete automated solution is unattainable. To worsen the situation, the manual analysis of the generated mutants of a program under test is prohibitive due to their vast number and the complexity of determining their equivalence. Objective: This paper focuses on the automated identification of equivalent and partially equivalent mutants, i.e. mutants that are equivalent to the original program for a specific subset of paths. To this end, the utilisation of a series of previously proposed data flow patterns is investigated. This study also examines the cross-language nature of these patterns and the killability of the detected partially equivalent mutants. Method: A tool, named MEDIC (Mutants' Equivalence DIsCovery), incorporating the aforementioned patterns was developed. Its efficiency and effectiveness were evaluated based on a set of manually analysed mutants from real-world programs, written in the Java programming language. Furthermore, MEDIC was employed to test subjects written in the JavaScript programming language. Results: MEDIC managed to detect 56% of the examined equivalent mutants in 125 s, providing strong evidence regarding both its effectiveness and efficiency. Additionally, MEDIC was able to identify equivalent mutants in the JavaScript test subjects, lending colour to the cross-language nature of the implemented patterns. Finally, the identified partially equivalent mutant set consisted largely of killable mutants, 16% of which were stubborn ones. Conclusion: It can be concluded that pattern-based equivalent mutant identification forms a viable approach for combating the equivalent mutant problem. MEDIC automatically detected a considerable number of the manually identified equivalent mutants and was successfully applied to test subjects in all examined programming languages.",
      "keywords": "Mutation testing Equivalent mutant detection Stubborn mutant detection Static analysis Data flow analysis",
      "references": [
        12,
        18,
        20,
        22,
        30,
        33,
        43,
        45,
        47,
        48,
        63,
        69,
        82,
        87,
        90,
        92,
        101,
        103,
        112
      ]
    },
    {
      "id": 114,
      "title": "Mutation Testing in Practice Using Ruby",
      "abstract": "Mutation testing is an effective testing technique to detect faults and improve code quality. However, few practitioners have adopted mutation testing into practice, which raises several questions: Are tests capable of killing mutants useful? What is the main hindrance to adopting mutation testing in practice? Can practitioners really integrate mutation testing into real-world agile development processes? In this paper, we present two major contributions. First, based on our analysis and knowledge of Ruby, we devised eight new mutation operators for Ruby. Second, we applied mutation testing to an industrial Ruby project at Medidata and reported the lessons learned from the study. We confirmed that mutation-adequate tests are useful and could improve code quality from the perspective of practitioners and found long mutation execution time hinders the agile process. In addition, we used an enterprise-level Amazon cloud-computing technique to reduce the computational cost of running mutants. Considering the availability of a mutation testing tool with our suggested features, we argue that mutation testing can be used in practice.",
      "keywords": "",
      "references": [
        5,
        17,
        30,
        76,
        81,
        83,
        95
      ]
    },
    {
      "id": 115,
      "title": "Fault-based Product-line Testing: Effective Sample Generation Based on Feature-Diagram Mutation",
      "abstract": "Testing every member of a product line individually is often impracticable due to large number of possible product configurations. Thus, feature models are frequently used to generate samples, i.e., subsets of product configurations under test. Besides the extensively studied combinatorial interaction testing (CIT) approach for coverage-driven sample generation, only few approaches exist so far adopting mutation testing to emulate faults in feature models to be detected by a sample. In this paper, we present a mutationbased sampling framework for fault-based product-line testing. We define a comprehensive catalog of atomic mutation operators on the graphical representation of feature models. This way, we are able (1) to also define complex mutation operators emulating more subtle faults, and (2) to classify operators semantically, e.g., to avoid redundant and equivalent mutants. We further introduce similarity-based mutant selection and higher order mutation strategies to reduce testing efforts. Our implementation is based on the graph transformation engine Henshin and is evaluated concerning effectiveness/efficiency trade-offs.",
      "keywords": "Mutation Testing, Combinatorial Interaction Testing",
      "references": [
        52,
        99
      ]
    },
    {
      "id": 116,
      "title": "Evaluation of Deletion Mutation Operators in Mutation Testing of C# Programs",
      "abstract": "Deletion mutation operators were endorsed to be beneficial in effective evaluation of tests for C and Java in comparison to traditional structural mutation operators. They were also supposed to generate fewer equivalent mutants. In this work we present evaluation of deletion mutation operators in the context of structural and object-oriented operators used in first and second order mutation testing of C# programs. Deletion operators could surpass standard mutation operators in the lower number of generated mutants and decreased mutation testing time. Experiments on C# programs were conducted on statement and operator deletion mutation operators. Considering mutation time, it could be profitable to replace other structural mutation operators with the deletion ones, although there are no distinctive results in reduction of the number of equivalent mutants. ",
      "keywords": "Mutation testing, Deletion mutation operators, Mutation cost reduction, C#, Visual Studio",
      "references": [
        17,
        44,
        55,
        61,
        76,
        92,
        95,
        96,
        103
      ]
    },
    {
      "id": 117,
      "title": "Featured Model-based Mutation Analysis",
      "abstract": "Model-based mutation analysis is a powerful but expensive testing technique. We tackle its high computation cost by proposing an optimization technique that drastically speeds up the mutant execution process. Central to this approach is the Featured Mutant Model, a modelling framework for mutation analysis inspired by the software product line paradigm. It uses behavioural variability models, viz., Featured Transition Systems, which enable the optimized generation, configuration and execution of mutants. We provide results, based on models with thousands of transitions, suggesting that our technique is fast and scalable. We found that it outperforms previous approaches by several orders of magnitude and that it makes higher-order mutation practically applicable. ",
      "keywords": "Mutation Analysis, Variability, Featured Transition Systems",
      "references": [
        9,
        23,
        30,
        49,
        60,
        91,
        98,
        100,
        104,
        110
      ]
    },
    {
      "id": 118,
      "title": "Topsy-Turvy: A Smarter and Faster Parallelization of Mutation Analysis",
      "abstract": "Mutation analysis is an effective, if computationally expensive, technique that allows practitioners to accurately evaluate the quality of their test suites. To reduce the time and cost of mutation analysis, researchers have looked at parallelizing mutation runs - - running multiple mutated versions of the program in parallel, and running through the tests in sequence on each mutated program until a bug is found. While an improvement over sequential execution of mutants and tests, this technique carries a significant overhead cost due to its redundant execution of unchanged code paths. In this paper we propose a novel technique (and its implementation) which parallelizes the test runs rather than the mutants, forking mutants from a single program execution at the point of invocation, which reduces redundancy. We show that our technique can lead to significant efficiency improvements and cost reductions. ",
      "keywords": "software testing, mutation analysis, parallelization",
      "references": [
        4,
        5,
        6,
        9,
        10,
        11,
        30,
        80,
        83,
        100,
        104,
        122
      ]
    },
    {
      "id": 119,
      "title": "Nequivack: Assessing Mutation Score Confidence",
      "abstract": "The mutation score is defined as the number of killed mutants divided by the number of non-equivalent mutants. However, whether a mutant is equivalent to the original program is undecidable in general. Thus, even when improving a test suite, a mutant score assessing this test suite may become worse during the development of a system, because of equivalent mutants introduced during mutant creation. This is a fundamental problem. Using static analysis and symbolic execution, we show how to establish non-equivalence or \"don't know\" among mutants. If the number of don't knows is small, this is a good indicator that a computed mutation score actually reflects its above definition. We can therefore have an increased confidence that mutation score trends correspond to actual improvements of a test suite's quality, and are not overly polluted by equivalent mutants. Using a set of 14 representative unit size programs, we show that for some, but not all, of these programs, the above confidence can indeed be established. We also evaluate the reproducibility, efficiency and effectiveness of our Nequivack tool. Our findings are that reproducibility is completely given. A single mutant analysis can be performed within 3 seconds on average, which is efficient for practical and industrial applications.",
      "keywords": "",
      "references": [
        18,
        20,
        28,
        49,
        87
      ]
    },
    {
      "id": 120,
      "title": "Analyzing the Validity of Selective Mutation with Dominator Mutants",
      "abstract": "Various forms of selective mutation testing have long been accepted as valid approximations to full mutation testing. This paper presents counterevidence to traditional selective mutation. The recent development of dominator mutants and minimal mutation analysis lets us analyze selective mutation without the noise introduced by the redundancy inherent in traditional mutation. We then exhaustively evaluate all small sets of mutation operators for the Proteum mutation system and determine dominator mutation scores and required work for each of these sets on an empirical test bed. The results show that all possible selective mutation approaches have poor dominator mutation scores on at least some of these programs. This suggests that to achieve high performance with respect to full mutation analysis, selective approaches will have to become more sophisticated, possibly by choosing mutants based on the specifics of the artifact under test, that is, specialized selective mutation.",
      "keywords": "Mutation analysis, subsumption, dominator mutants",
      "references": [
        8,
        14,
        15,
        17,
        24,
        32,
        38,
        44,
        52,
        76,
        81,
        92,
        95,
        97,
        111
      ]
    },
    {
      "id": 121,
      "title": "Evaluating Different Strategies for Reduction of Mutation Testing Costs",
      "abstract": "Mutation testing presents high efficacy in terms of revealed faults, but with high computational costs, because test cases must be executed against a great number of mutants. To reduce such costs several strategies exist. In general, they select a reduced number of mutants that maintain a great overall mutation score. Recently, Higher-Order Mutation Testing (HOM) was proposed. HOM introduces more than one fault at a time in the mutants such that they are harder to kill. This kind of testing can also be used as a cost reduction strategy. However, few works in literature evaluate the cost reduction potential of HOM or compare it to other existing strategies. In this work, we evaluate HOM as a mutation testing cost reduction strategy. We conducted an experiment to compare four HOM-based strategies (First to Last, Random Mix, Different Operators, and Each-Choice) and three conventional ones (Random Mutant Selection, Selective Mutation, and Search-Based Mutation by using Genetic Algorithm). The analysis considers the number of selected mutants, number of test cases, mutation score and efficiency measures. Selective Mutation presented the best results overall. Among the HOM-based strategies, Each-Choice was the best. ",
      "keywords": "Fault-based Testing; Higher-Order Mutation; Mutation Testing Strategies",
      "references": [
        8,
        9,
        14,
        15,
        17,
        24,
        30,
        38,
        40,
        43,
        45,
        47,
        48,
        92,
        95,
        98,
        103
      ]
    },
    {
      "id": 122,
      "title": "Mutation Testing Cost Reduction by Clustering Overlapped Mutants",
      "abstract": "Mutation testing is a powerful but computationally expensive testing technique. Several approaches have been developed to reduce the cost of mutation testing by decreasing the number of mutants to be executed; however, most of these approaches are not as effective as mutation testing which uses a full set of mutants. This paper presents a new approach for executing fewer mutants while retaining nearly the same degree of effectiveness as is produced by mutation testing using a full set of mutants. Our approach dynamically clusters expression-level weakly killed mutants that are expected to produce the same result under a test case; only one mutant from each cluster is fully executed under the test case. We implemented this approach and demonstrated that our approach efficiently reduced the cost of mutation testing without loss of effectiveness. ",
      "keywords": "software testing; mutation testing; dynamic analysis",
      "references": [
        10,
        13,
        14,
        17,
        40,
        45,
        66,
        81,
        84,
        92
      ]
    },
    {
      "id": 123,
      "title": "Virtual Mutation Analysis of Relational Database Schemas",
      "abstract": "Relational databases are a vital component of many modern software applications. Key to the definition of the database schema - which specifies what types of data will be stored in the database and the structure in which the data is to be organized - are integrity constraints. Integrity constraints are conditions that protect and preserve the consistency and validity of data in the database, preventing data values that violate their rules from being admitted into database tables. They encode logic about the application concerned, and like any other component of a software application, need to be properly tested. Mutation analysis is a technique that has been successfully applied to integrity constraint testing, seeding database schema faults of both omission and commission. Yet, as for traditional mutation analysis for program testing, it is costly to perform, since the test suite under analysis needs to be run against each individual mutant to establish whether or not it exposes the fault. One overhead incurred by database schema mutation is the cost of communicating with the database management system (DBMS). In this paper, we seek to eliminate this cost by performing mutation analysis virtually on a local model of the DBMS, rather than on an actual, running instance hosting a real database. We present an empirical evaluation of our virtual technique revealing that, across all of the studied DBMSs and schemas, the virtual method yields an average time saving of 51% over the baseline. ",
      "keywords": "",
      "references": [
        36,
        56,
        88,
        106
      ]
    },
    {
      "id": 124,
      "title": "Evaluating Random Mutant Selection at Class-level in Projects with Non-adequate Test Suites",
      "abstract": " Mutation testing is a standard technique to evaluate the quality of a test suite. Due to its computationally intensive nature, many approaches have been proposed to make this technique feasible in real case scenarios. Among these approaches, uniform random mutant selection has been demonstrated to be simple and promising. However, works on this area analyze mutant samples at project level mainly on projects with adequate test suites. In this paper, we fill this lack of empirical validation by analyzing random mutant selection at class level on projects with non-adequate test suites. First, we show that uniform random mutant selection underachieves the expected results. Then, we propose a new approach named weighted random mutant selection which generates more representative mutant samples. Finally, we show that representative mutant samples are larger for projects with high test adequacy. ",
      "keywords": "",
      "references": [
        8,
        15,
        17,
        24,
        38,
        52,
        79,
        90
      ]
    },
    {
      "id": 125,
      "title": "Improving Mutant Generation for Simulink Models Using Genetic Algorithm",
      "abstract": " Simulink is one of the most popular tools used to design dynamic models for industrial complex systems. Mutation testing is a fault-based technique widely used for testing software. However, the testing cost is often very high. A tool which allows automatic testing for Simulink models with only a subset of mutants to reduce testing costs and time while ensuring the quality of software products is very neccessary. This paper proposes the use of genetic algorithm to minimize the number of generated mutants without losing the efficiency of mutation testing approach. The experiment confirms that the proposed method contributed to the reduction in time and costs for mutation testing process. ",
      "keywords": "mutation testing, mutant, genetic algorithm, Simulink model, fitness function",
      "references": [
        39
      ]
    },
    {
      "id": 126,
      "title": "Predictive Mutation Testing",
      "abstract": " Mutation analysis can provide valuable insights into both the system under test and its test suite. However, it is not scalable due to the cost of building and testing a large number of mutants. Predictive Mutation Testing (PMT) has been proposed to reduce the cost of mutation testing, but it can only provide statistical inference about whether a mutant will be killed or not by the entire test suite. We propose Seshat, a Predictive Mutation Analysis (PMA) technique that can accurately predict the entire kill matrix, not just the Mutation Score (MS) of the given test suite. Seshat exploits the natural language channel in code, and learns the relationship between the syntactic and semantic concepts of each test case and the mutants it can kill, from a given kill matrix. The learnt model can later be used to predict the kill matrices for subsequent versions of the program, even after both the source and test code have changed significantly. Empirical evaluation using the programs in Defects4J shows that Seshat can predict kill matrices with an average F-score of 0.83 for versions that are up to years apart. This is an improvement in F-score by 0.14 and 0.45 points over the state-of-the-art PMT technique and a simple coverage-based heuristic, respectively. Seshat also performs as well as PMT for the prediction of the MS only. When applied to a mutant-based fault localisation technique, the predicted kill matrix by Seshat is successfully used to locate faults within the top 10 position, showing its usefulness beyond prediction of MS. Once Seshat trains its model using a concrete mutation analysis, the subsequent predictions made by Seshat are on average 39 times faster than actual test-based analysis. We also show that Seshat can be successfully applied to automatically generated test cases with an experiment using EvoSuite.",
      "keywords": "Mutation analysis, deep learning",
      "references": [
        9,
        13,
        17,
        38,
        49,
        72,
        89,
        144
      ]
    },
    {
      "id": 127,
      "title": "An Approach for the Generation of Higher Order Mutants Using Genetic Algorithms",
      "abstract": " Mutation testing is a structural testing technique in which the effectiveness of a test suite is measured by the suite ability to detect seeded faults. One fault is seeded into a copy of the program, called mutant, leading to a large number of mutants with a high cost of compiling and running the test suite against the mutants. Moreover, many of the mutants produce the same output as the original program (called equivalent mutants), such mutants need to be minimized to produce accurate results. Higher order mutation testing aims at solving these problems by allowing more than one fault to be seeded in the mutant. Recent work in higher order mutation show promising result in reducing the cost of mutation testing and increasing the approach effectiveness. In this paper, we present an approach for generating higher order mutants using a genetic algorithm. The aim of the proposed approach is to produce subtle and harder to kill mutants, and reduce the percentage of produced equivalent mutants. A Java tool has been developed, called HOMJava (Higher Order Mutation for Java), which implements the proposed approach. An experimental study was performed to evaluate the effectiveness of the proposed approach. The results show that the approach was able to produce subtle higher order mutants, the fitness of mutants improved by almost 99% compared with the first order mutants used in the experiment. The percentage of produced equivalent mutants was about 4%. ",
      "keywords": "Higher order mutant, mutation testing, genetic algorithm, software testing, equivalent mutants,evolutionary approach",
      "references": [
        12,
        13,
        18,
        20,
        21,
        28,
        30,
        68,
        71,
        84,
        87,
        103,
        112
      ]
    },
    {
      "id": 128,
      "title": "Efficient Mutation Testing in Configurable Systems",
      "abstract": " Mutation testing is a technique to evaluate the quality of test cases by assessing their ability to detect faults. Mutants are modified versions of the original program that are generated automatically and should contain faults similar to those caused by developers' mistakes. For configurable systems, existing approaches propose mutation operators to produce faults that may only exist in some configurations. However, due to the number of possible configurations, generating and testing all mutants for each program is not feasible. To tackle this problem, we discuss to use static analysis and adopt the idea of T-wise testing to limit the number of mutants. In particular, we i) discuss dependencies that exist in configurable systems, ii) how we can use them to identify code to mutate, and iii) assess the expected outcome. Our preliminary results show that variability analysis can help to reduce the number of mutants and, thus, costs for testing.",
      "keywords": "",
      "references": [
        2,
        8,
        15,
        38,
        44,
        45,
        76,
        90,
        99,
        115,
        117
      ]
    },
    {
      "id": 129,
      "title": "Improved Genetic Algorithm to Reduce Mutation Testing Cost",
      "abstract": " Mutation testing is a fault-based testing technique that helps generating effective test cases. Mutation testing is computationally expensive, because it requires executing hundreds and even thousands of mutants. In this situation, search-based approaches like genetic algorithm can help to automate test case generation to reduce the cost. In this paper, we present an improved genetic algorithm that can reduce computational cost of mutation testing. First, we present a novel state-based and control-oriented fitness function that efficiently uses object-oriented program features to evaluate a test case. We then empirically evaluate it using our implemented tool, eMuJava, and compare it with the standard fitness function. Results show that although our proposed fitness function provides detailed information about fitness of a test case but standard genetic algorithm is incapable of using that effectively to repair the test cases. Therefore, we propose a new two-way crossover and adaptable mutation methods that intelligently use the fitness information to generate fitter offspring. Finally, we compare the improved genetic algorithm with random testing, standard genetic algorithm, and EvoSuite. Experiment results prove that our proposed approach can find the optimal test cases in less number of attempts (reduces computational cost). Besides that it can detect software bugs from suspiciously equivalent mutants and these mutants eventually get killed (increases mutation score).",
      "keywords": "Control flow of program, genetic algorithms, mutation testing, object oriented programming, object\u2019s state, suspicious mutant, two-way crossover",
      "references": [
        15,
        17,
        26,
        33,
        54,
        59,
        63,
        110
      ]
    },
    {
      "id": 130,
      "title": "GiGAn: Evolutionary Mutation Testing for C++ Object-oriented Systems",
      "abstract": " The reduction of the expenses of mutation testing should be based on well-studied cost reduction techniques to avoid biased results. Evolutionary Mutation Testing (EMT) aims at generating a reduced set of mutants by means of an evolutionary algorithm, which searches for potentially equivalent and difficult to kill mutants to help improve the test suite. However, there is little evidence of its applicability to other contexts beyond WS-BPEL compositions. This study explores its performance when applied to C++ object-oriented programs thanks to a newly developed system, GiGAn. The conducted experiments reveal that EMT shows stable behavior in all the case studies, where the best results are obtained when a low percentage of the mutants is generated. They also support previous studies of EMT when compared to random mutant selection, reinforcing its use for the goal of improving the fault detection capability of the test suite. ",
      "keywords": "mutation testing; evolutionary computation; genetic algorithm; object orientation; C++.",
      "references": [
        24,
        28,
        39,
        54,
        85,
        132
      ]
    },
    {
      "id": 131,
      "title": "Assessment of C++ Object-Oriented Mutation Operators: A Selective Mutation Approach",
      "abstract": " Mutation testing is an effective but costly testing technique. Several studies have observed that some mutants can be redundant and therefore removed without affecting its effectiveness. Similarly, some mutants may be more effective than others in guiding the tester on the creation of high-quality test cases. On the basis of these findings, we present an assessment of C++ class mutation operators by classifying them into 2 rankings: the first ranking sorts the operators on the basis of their degree of redundancy and the second regarding the quality of the tests they help to design. Both rankings are used in a selective mutation study analysing the trade-off between the reduction achieved and the effectiveness when using a subset of mutants. Experimental results consistently show that leveraging the operators at the top of the 2 rankings, which are different, lead to a significant reduction in the number of mutants with a minimum loss of effectiveness. ",
      "keywords": "class mutation operators,C++,mutation testing, selectivemutation, quality ofmutation operators",
      "references": [
        8,
        15,
        17,
        21,
        24,
        38,
        52,
        54,
        61,
        90,
        92,
        93,
        94,
        97,
        106,
        132
      ]
    },
    {
      "id": 132,
      "title": "Assessment of Class Mutation Operators for C++ with the MuCPP Mutation System",
      "abstract": " Context: Mutation testing has been mainly analyzed regarding traditional mutation operators involving structured programming constructs common in mainstream languages, but mutations at the class level have not been assessed to the same extent. This fact is noteworthy in the case of C++, despite being one of the most relevant languages including object-oriented features. Objective: This paper provides a complete evaluation of class operators for the C++ programming language. MuCPP, a new system devoted to the application of mutation testing to this language, was developed to this end. This mutation system implements class mutation operators in a robust way, dealing with the inherent complexity of the language. Method: MuCPP generates the mutants by traversing the abstract syntax tree of each translation unit with the Clang API, and stores mutants as branches in the Git version control system. The tool is able to detect duplicate mutants, avoid system headers, and drive the compilation process. Then, MuCPP is used to conduct experiments with several open-source C++ programs. Results: The improvement rules listed in this paper to reduce unproductive class mutants have a significant impact in the computational cost of the technique. We also calculate the quantity and distribution of mutants generated with class operators, which generate far fewer mutants than their traditional counterparts. Conclusions: We show that the tests accompanying these programs cannot detect faults related to particular object-oriented features of C++. In order to increase the mutation score, we create new test scenarios to kill the surviving class mutants for all the applications. The results confirm that, while traditional mutation operators are still needed, class operators can complement them and help testers further improve the test suite. ",
      "keywords": "Mutation testing, Mutation system, C++, Class mutation operators , Object-oriented programming",
      "references": [
        8,
        17,
        21,
        28,
        33,
        39,
        61,
        81,
        94,
        100,
        104,
        111
      ]
    },
    {
      "id": 133,
      "title": "Using Evolutionary Computation to Improve Mutation Testing",
      "abstract": " The work on mutation testing has attracted a lot of attention during the last decades. Mutation testing is a powerful mechanism to improve the quality of test suites based on the injection of syntactic changes into the code of the original program. Several studies have focused on reducing the high computational cost of applying this technique and increasing its efficiency. Only some of them have tried to do it through the application of genetic algorithms. Genetic algorithms can guide through the generation of a reduced subset of mutants without significant loss of information. In this paper, we analyse recent advances in mutation testing that contribute to reduce the cost associated to this technique and propose to apply them for addressing current drawbacks in Evolutionary Mutation Testing (EMT), a genetic algorithm based technique with promising experimental results so far. ",
      "keywords": " Mutation testing, evolutionary computation,object-oriented programming, C++.\n",
      "references": [
        24,
        28,
        39,
        54,
        85,
        130,
        132
      ]
    },
    {
      "id": 134,
      "title": "Evaluation of Mutant Sampling Criteria in Object-Oriented Mutation Testing",
      "abstract": " Mutation testing of object-oriented programs differs from that of standard (traditional) mutation operators in accordance to the number of generated mutants and ability of tests to kill mutants. Therefore, outcomes of cost reduction analysis cannot be directly transferred from a standard mutation to an object-oriented one. Mutant sampling is one of reduction methods of the number of generated and tested mutants. We proposed different mutant sampling criteria based on equivalence partitioning in respect to object-oriented program features. The criteria were experimentally evaluated for object-oriented and standard mutation operators applied in C# programs. We compared results using a quality metric, which combines mutation score accuracy with mutation cost factors. In result, class random sampling and operator random sampling are recommended for OO and standard mutation testing, accordingly. With a reasonable decline of result accuracy, the mutant sampling technique is easily applicable in comparison to other cost reduction techniques.",
      "keywords": "",
      "references": [
        8,
        15,
        24,
        28,
        52,
        55,
        61,
        74,
        77,
        90,
        122,
        131,
        143
      ]
    },
    {
      "id": 135,
      "title": "Automata Language Equivalence vs. Simulations for Model-Based Mutant Equivalence: An Empirical Evaluation",
      "abstract": " Mutation analysis is a popular test assessment method. It relies on the mutation score, which indicates how many mutants are revealed by a test suite. Yet, there are mutants whose behaviour is equivalent to the original system, wasting analysis resources and preventing the satisfaction of the full (100%) mutation score. For finite behavioural models, the Equivalent Mutant Problem (EMP) can be addressed through language equivalence of non-deterministic finite automata, which is a well-studied, yet computationally expensive, problem in automata theory. In this paper, we report on our preliminary assessment of a state-of-the-art exact language equivalence tool to handle the EMP against 3 models of size up to 15,000 states on 1170 mutants. We introduce random and mutation-biased simulation heuristics as baselines for comparison. Results show that the exact approach is often more than ten times faster in the weak mutation scenario. For strong mutation, our biased simulations are faster for models larger than 300 states. They can be up to 1,000 times faster while limiting the error of misclassifying non-equivalent mutants as equivalent to 10% on average. We therefore conclude that the approaches can be combined for improved efficiency. ",
      "keywords": "model-based mutation analysis; automata language equivalence; random simulations",
      "references": [
        20,
        49,
        91,
        110,
        117,
        146
      ]
    },
    {
      "id": 136,
      "title": "Avoiding Useless Mutants",
      "abstract": " Mutation testing is a program-transformation technique that injects artificial bugs to check whether the existing test suite can detect them. However, the costs of using mutation testing are usually high, hindering its use in industry. Useless mutants (equivalent and duplicated) contribute to increase costs. Previous research has focused mainly on detecting useless mutants only after they are generated and compiled. In this paper, we introduce a strategy to help developers with deriving rules to avoid the generation of useless mutants. To use our strategy, we pass as input a set of programs. For each program, we also need a passing test suite and a set of mutants. As output, our strategy yields a set of useless mutants candidates. After manually confirming that the mutants classified by our strategy as \"useless\" are indeed useless, we derive rules that can avoid their generation and thus decrease costs. To the best of our knowledge, we introduce 37 new rules that can avoid useless mutants right before their generation. We then implement a subset of these rules in the MUJAVA mutation testing tool. Since our rules have been derived based on artificial and small Java programs, we take our MUJAVA version embedded with our rules and execute it in industrial-scale projects. Our rules reduced the number of mutants by almost 13% on average. Our results are promising because (i) we avoid useless mutants generation; (ii) our strategy can help with identifying more rules in case we set it to use more complex Java programs; and (iii) our MUJAVA version has only a subset of the rules we derived. ",
      "keywords": "Mutation Testing, Equivalent Mutants, Duplicated Mutants, Program Transformation, Code Generation",
      "references": [
        18,
        20,
        28,
        30,
        33,
        43,
        87,
        103,
        113,
        139,
        140
      ]
    },
    {
      "id": 137,
      "title": "Mutation Reduction Strategies Considered Harmful",
      "abstract": " Mutation analysis is a well known yet unfortunately costly method for measuring test suite quality. Researchers have proposed numerous mutation reduction strategies in order to reduce the high cost of mutation analysis, while preserving the representativeness of the original set of mutants. As mutation reduction is an area of active research, it is important to understand the limits of possible improvements. We theoretically and empirically investigate the limits of improvement in effectiveness from using mutation reduction strategies compared to random sampling. Using real-world open source programs as subjects, we find an absolute limit in improvement of effectiveness over random sampling - 13.078%. Given our findings with respect to absolute limits, one may ask: How effective are the extant mutation reduction strategies? We evaluate the effectiveness of multiple mutation reduction strategies in comparison to random sampling. We find that none of the mutation reduction strategies evaluated - many forms of operator selection, and stratified sampling (on operators or program elements) - produced an effectiveness advantage larger than 5% in comparison with random sampling. Given the poor performance of mutation selection strategies - they may have a negligible advantage at best, and often perform worse than random sampling - we caution practicing testers against applying mutation reduction strategies without adequate justification. ",
      "keywords": "Mutation analysis, software testing",
      "references": [
        8,
        14,
        15,
        17,
        21,
        24,
        32,
        38,
        40,
        43,
        44,
        52,
        76,
        77,
        90,
        92,
        96,
        122
      ]
    },
    {
      "id": 138,
      "title": "Reducing Mutants with Mutant Killable Precondition",
      "abstract": " Mutation analysis is a method for predicting the quality of test suite accurately. However, it has high computational cost due to the number of mutants that are generated. For example, the ROR (Relational Operator Replacement) mutation operator will generate seven mutants for just one relational operator. Naively applying multiple operators over the entire program can result in a high number of generated mutants. One way to reduce the number of mutants is to omit redundant mutants. In this paper, we propose an approach to reducing mutants by using mutant killable precondition to identify redundant mutants. A mutant killable precondition is a logical expression for killing a mutant. We focus on the conditional expression for control flow statements, such as if and while statements. We describe the mutant killable precondition for conditional expressions that compare numbers, e.g., x > 0. We then discuss mutants that are generated for such conditional expressions, and find the minimal set of mutants. Finally, we show the theoretical and empirical reduction rate of our approach.",
      "keywords": "",
      "references": [
        8,
        13,
        30,
        81,
        122,
        126
      ]
    },
    {
      "id": 139,
      "title": "Inferring Mutant Utility from Program Context",
      "abstract": " Existing mutation techniques produce vast numbers of equivalent, trivial, and redundant mutants. Selective mutation strategies aim to reduce the inherent redundancy of full mutation analysis to obtain most of its benefit for a fraction of the cost. Unfortunately, recent research has shown that there is no fixed selective mutation strategy that is effective across a broad range of programs; the utility (i.e., usefulness) of a mutant produced by a given mutation operator varies greatly across programs. This paper hypothesizes that mutant utility, in terms of equivalence, triviality, and dominance, can be predicted by incorporating context information from the program in which the mutant is embedded. Specifically, this paper (1) explains the intuition behind this hypothesis with a motivational example, (2) proposes an approach for modeling program context using a program's abstract syntax tree, and (3) proposes and evaluates a series of program-context models for predicting mutant utility. The results for 129 mutation operators show that program context information greatly increases the ability to predict mutant utility. The results further show that it is important to consider program context for individual mutation operators rather than mutation operator groups. ",
      "keywords": "Mutation analysis, program mutation, program context, mutant utility, equivalent mutants, trivial mutants",
      "references": [
        8,
        12,
        14,
        15,
        17,
        18,
        20,
        22,
        28,
        52,
        81,
        87,
        92,
        100,
        111,
        120
      ]
    },
    {
      "id": 140,
      "title": "Detecting Trivial Mutant Equivalences via Compiler Optimisations",
      "abstract": " Mutation testing realises the idea of fault-based testing, i.e., using artificial defects to guide the testing process. It is used to evaluate the adequacy of test suites and to guide test case generation. It is a potentially powerful form of testing, but it is well-known that its effectiveness is inhibited by the presence of equivalent mutants. We recently studied Trivial Compiler Equivalence (TCE) as a simple, fast and readily applicable technique for identifying equivalent mutants for C programs. In the present work, we augment our findings with further results for the Java programming language. TCE can remove a large portion of all mutants because they are determined to be either equivalent or duplicates of other mutants. In particular, TCE equivalent mutants account for 7.4 and 5.7 percent of all C and Java mutants, while duplicated mutants account for a further 21 percent of all C mutants and 5.4 percent Java mutants, on average. With respect to a benchmark ground truth suite (of known equivalent mutants), approximately 30 percent (for C) and 54 percent (for Java) are TCE equivalent. It is unsurprising that results differ between languages, since mutation characteristics are language-dependent. In the case of Java, our new results suggest that TCE may be particularly effective, finding almost half of all equivalent mutants. ",
      "keywords": "Mutation testing, equivalent mutants, duplicated mutants, compiler optimisation",
      "references": [
        9,
        12,
        15,
        17,
        18,
        20,
        22,
        28,
        30,
        38,
        43,
        45,
        47,
        48,
        49,
        52,
        65,
        76,
        81,
        82,
        87,
        89,
        92,
        95,
        98,
        101,
        103,
        104,
        105,
        112,
        113,
        120
      ]
    },
    {
      "id": 141,
      "title": "Finding Redundancy in Web Mutation Operators",
      "abstract": " New web development technologies enhance functionality of web applications but also introduce challenges in testing the software. As mutation analysis has been shown to be effective at designing tests for traditional software, we previously proposed web mutation testing. However, applying mutation analysis can be computationally expensive due to an extensive number of test requirements. This paper introduces, evaluates, and refines web mutation operators with the goal of reducing the number of test requirements. This paper evaluates redundancy among web mutation operators by analyzing the types of mutants that can be killed by tests generated specifically to kill other types of mutants and the types of mutants (and the operators that generate them) that can be excluded from testing while maintaining the same level of fault detection. An experimental study was conducted on 12 subject web applications using 15 web mutation operators. The redundancy in web mutation operators is computed as the percentage of the mutants of each operator that are killed by tests designed specifically to kill mutants of other operators. Tests designed specifically to kill mutants of some operators can also kill mutants generated from other operators. Three overlapping web mutation operators (WFUR, WHID, and WLUD) are redundant and can be excluded from mutation testing with minimal loss in fault detection capability.",
      "keywords": "",
      "references": [
        15,
        17,
        30,
        58,
        76,
        81,
        92,
        95,
        120
      ]
    },
    {
      "id": 142,
      "title": "An Empirical Study on Mutation Testing of WS-BPEL Programs",
      "abstract": " Nowadays, applications are increasingly deployed as Web services in the globally distributed cloud computing environment. Multiple services are normally composed to fulfill complex functionalities. Business Process Execution Language for Web Services (WS-BPEL) is an XML-based service composition language that is used to define a complex business process by orchestrating multiple services. Compared with traditional applications, WS-BPEL programs pose many new challenges to the quality assurance, especially testing, of service compositions. A number of techniques have been proposed for testing WS-BPEL programs, but only a few studies have been conducted to systematically evaluate the effectiveness of these techniques. Mutation testing has been widely acknowledged as not only a testing method in its own right but also a popular technique for measuring the fault-detection effectiveness of other testing methods. Several previous studies have proposed a family of mutation operators for generating mutants by seeding various faults into WS-BPEL programs. In this study, we conduct a series of empirical studies to evaluate the applicability and effectiveness of various mutation operators for WS-BPEL programs. The experimental results provide insightful and comprehensive guidance for mutation testing of WS-BPEL programs in practice. In particular, our work is the systematic study in the selection of effective mutation operators specifically for WS-BPEL programs.",
      "keywords": "web service; service composition; Business Process Execution Language for Web Services; mutation testing",
      "references": [
        17,
        24,
        38,
        47,
        52,
        63,
        72,
        106
      ]
    },
    {
      "id": 143,
      "title": "A Path-aware Approach to Mutant Reduction in Mutation Testing",
      "abstract": " Context: Mutation testing, which systematically generates a set of mutants by seeding various faults into the base program under test, is a popular technique for evaluating the effectiveness of a testing method. However, it normally requires the execution of a large amount of mutants and thus incurs a high cost. Objective: A common way to decrease the cost of mutation testing is mutant reduction, which selects a subset of representative mutants. In this paper, we propose a new mutant reduction approach from the perspective of program structure. Method: Our approach attempts to explore path information of the program under test, and select mutants that are as diverse as possible with respect to the paths they cover. We define two path-aware heuristic rules, namely module-depth and loop-depth rules, and combine them with statement- and operator-based mutation selection to develop four mutant reduction strategies. Results: We evaluated the cost-effectiveness of our mutant reduction strategies against random mutant selection on 11 real-life C programs with varying sizes and sampling ratios. Our empirical studies show that two of our mutant reduction strategies, which primarily rely on the path-aware heuristic rules, are more effective and systematic than pure random mutant selection strategy in terms of selecting more representative mutants. In addition, among all four strategies, the one giving loop-depth the highest priority has the highest effectiveness. Conclusion: In general, our path-aware approach can reduce the number of mutants without jeopardizing its effectiveness, and thus significantly enhance the overall cost-effectiveness of mutation testing. Our approach is particularly useful for the mutation testing on large-scale complex programs that normally involve a huge amount of mutants with diverse fault characteristics. ",
      "keywords": "Mutation testing, Selective mutation testing, Control flow, Path depth",
      "references": [
        8,
        9,
        12,
        15,
        17,
        20,
        25,
        30,
        38,
        40,
        45,
        48,
        52,
        63,
        69,
        72,
        79,
        89,
        90,
        95,
        98,
        105,
        111,
        112
      ]
    },
    {
      "id": 144,
      "title": "Faster Mutation Analysis via Equivalence Modulo States",
      "abstract": " Mutation analysis has many applications, such as asserting the quality of test suites and localizing faults. One important bottleneck of mutation analysis is scalability. .e latest work explores the possibility of reducing the redundant execution via split-stream execution. However, split-stream execution is only able to remove redundant execution before the first mutated statement. In this paper we try to also reduce some of the redundant execution after the execution of the first mutated statement. We observe that, although many mutated statements are not equivalent, the execution result of those mutated statements may still be equivalent to the result of the original statement. In other words, the statements are equivalent modulo the current state. In this paper we propose a fast mutation analysis approach, AccMut. AccMut automatically detects the equivalence modulo states among a statement and its mutations, then groups the statements into equivalence classes modulo states, and uses only one process to represent each class. In this way, we can significantly reduce the number of split processes. Our experiments show that our approach can further accelerate mutation analysis on top of split-stream execution with a speedup of 2.56x on average.",
      "keywords": "software testing; mutation testing; dynamic analysis",
      "references": [
        4,
        5,
        9,
        12,
        15,
        40,
        52,
        53,
        62,
        63,
        64,
        65,
        72,
        79,
        84,
        89,
        98,
        100,
        110,
        111,
        117,
        118,
        120,
        126,
        139
      ]
    },
    {
      "id": 145,
      "title": "Speeding-Up Mutation Testing via Data Compression and State Infection",
      "abstract": " Mutation testing is widely considered as a high-end test criterion due to the vast number of mutants it generates. Although many efforts have been made to reduce the computational cost of mutation testing, its scalability issue remains in practice. In this paper, we introduce a novel method to speed up mutation testing based on state infection information. In addition to filtering out uninfected test executions, we further select a subset of mutants and a subset of test cases to run leveraging data-compression techniques. In particular, we adopt Formal Concept Analysis (FCA) to group similar mutants together and then select test cases to cover these mutants. To evaluate our method, we conducted an experimental study on six open source Java projects. We used EvoSuite to automatically generate test cases and to collect mutation data. The initial results show that our method can reduce the execution time by 83.93% with only 0.257% loss in precision. ",
      "keywords": "",
      "references": [
        17,
        40,
        65,
        89,
        92,
        100,
        110,
        122
      ]
    },
    {
      "id": 146,
      "title": "Resolving the Equivalent Mutant Problem in the Presence of Non-determinism and Coincidental Correctness",
      "abstract": "In this paper, we develop a new mutation testing technique called Interlocutory Mutation Testing (IMT) that mitigates the equivalent mutant problem in the presence of coincidental correctness and non-determinism. The accuracy of IMT was evaluated; it obtained a classification accuracy of 93.33 % for non-equivalent mutants and 100 % for equivalent mutants in a non-deterministic system with coincidental correctness.",
      "keywords": "Mutation testing, Coincidental correctness,  Nondeterminism, Equivalent mutant problem",
      "references": [
        46
      ]
    }
  ],
  "min_publication_year": 1987,
  "max_publication_year": 2018
}